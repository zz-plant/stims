<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Capability Visualizer (WebGPU/WebGL Fallback)</title>
    <link rel="stylesheet" href="assets/css/base.css" />
    <style>
      body,
      html {
        height: 100%;
        background-color: #000000;
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="home-link">Back to Library</a>
    <canvas id="webglCanvas"></canvas>
    <div id="error-message" style="display: none"></div>
    <script type="module">
      import * as THREE from 'three';
      import WebToy from './assets/js/core/web-toy.ts';
      import {
        startAudioLoop,
        getContextFrequencyData,
      } from './assets/js/core/animation-loop.ts';
      import { getAverageFrequency } from './assets/js/utils/audio-handler.ts';
      import { createPeakDetector } from './assets/js/utils/peak-detector.ts';
      import { FunControls } from './assets/js/utils/fun-controls.ts';
      import { createSparkleLayer } from './assets/js/utils/sparkle-layer.ts';

      const canvas = document.getElementById('webglCanvas');
      const sparkleLayer = createSparkleLayer(document.body, {
        pixelRatio: Math.min(window.devicePixelRatio, 2),
      });

      const controls = new FunControls('Effects');
      const settings = { sparkles: true, bursts: true, sensitivity: 1.4 };
      controls.addToggle(
        'multi-sparkles',
        'Sparkles',
        settings.sparkles,
        (v) => {
          settings.sparkles = v;
        }
      );
      controls.addToggle('multi-bursts', 'Bursts', settings.bursts, (v) => {
        settings.bursts = v;
      });
      controls.addRange('multi-sensitivity', 'Peak Sensitivity', {
        min: 1,
        max: 2,
        step: 0.02,
        defaultValue: settings.sensitivity,
        onChange: (v) => {
          settings.sensitivity = v;
          peakDetector.setSensitivity(v);
        },
      });

      const peakDetector = createPeakDetector({
        sensitivity: settings.sensitivity,
        cooldownMs: 180,
      });
      let burstStrength = 0;
      let lastFrame = performance.now();

      function displayError(message) {
        const el = document.getElementById('error-message');
        if (el) {
          el.innerText = message;
          el.style.display = 'block';
        }
      }

      const toy = new WebToy({
        canvas,
        cameraOptions: {
          fov: 75,
          position: { x: 0, y: 0, z: 50 },
        },
        rendererOptions: {
          antialias: true,
          exposure: 1,
          maxPixelRatio: 2,
        },
        ambientLightOptions: { color: 0xffffff, intensity: 1 },
      });

      const torusKnot = new THREE.Mesh(
        new THREE.TorusKnotGeometry(10, 3, 100, 16),
        new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          metalness: 0.5,
          roughness: 0.2,
        })
      );
      toy.scene.add(torusKnot);

      const pointLight = new THREE.PointLight(0xff0000, 2, 100);
      pointLight.position.set(10, 20, 20);
      toy.scene.add(pointLight);

      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 1000;
      const particlesPosition = new Float32Array(particlesCount * 3);
      for (let i = 0; i < particlesCount * 3; i++) {
        particlesPosition[i] = (Math.random() - 0.5) * 500;
      }
      particlesGeometry.setAttribute(
        'position',
        new THREE.BufferAttribute(particlesPosition, 3)
      );
      const particlesMaterial = new THREE.PointsMaterial({
        color: 0x00ff00,
        size: 0.5,
      });
      const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      toy.scene.add(particles);

      const shapes = [];
      function createRandomShape() {
        const shapeType = Math.floor(Math.random() * 3);
        let shape;
        const shapeMaterial = new THREE.MeshStandardMaterial({
          color: Math.random() * 0xffffff,
          emissive: Math.random() * 0x222222,
          metalness: 0.7,
          roughness: 0.4,
        });

        switch (shapeType) {
          case 0:
            shape = new THREE.SphereGeometry(5, 32, 32);
            break;
          case 1:
            shape = new THREE.BoxGeometry(7, 7, 7);
            break;
          default:
            shape = new THREE.ConeGeometry(5, 15, 32);
            break;
        }

        const mesh = new THREE.Mesh(shape, shapeMaterial);
        mesh.position.set(
          Math.random() * 100 - 50,
          Math.random() * 100 - 50,
          Math.random() * -500
        );
        toy.scene.add(mesh);
        shapes.push(mesh);
      }

      for (let i = 0; i < 5; i++) {
        createRandomShape();
      }

      function handlePeak(intensity) {
        if (settings.sparkles) {
          sparkleLayer.spawn(10);
        }
        if (settings.bursts) {
          burstStrength = Math.min(1, burstStrength + intensity * 0.5);
        }
      }

      window.addEventListener('deviceorientation', (event) => {
        toy.camera.rotation.x = (event.beta / 180) * Math.PI;
        toy.camera.rotation.y = (event.gamma / 90) * Math.PI;
      });

      function animate(ctx) {
        const now = performance.now();
        const delta = now - lastFrame;
        lastFrame = now;
        const dataArray = getContextFrequencyData(ctx);
        const avgFrequency = getAverageFrequency(dataArray);
        const normalized = avgFrequency / 255;

        if (peakDetector.update(normalized)) {
          handlePeak(normalized);
        }

        torusKnot.rotation.x += avgFrequency / 5000;
        torusKnot.rotation.y += avgFrequency / 5000;

        pointLight.intensity = avgFrequency / 100 + burstStrength * 2;

        particles.rotation.y += 0.001 + avgFrequency / 100000;

        shapes.forEach((shape) => {
          const burstSpin = burstStrength * 0.05;
          shape.rotation.x += 0.01 + burstSpin;
          shape.rotation.y += 0.01 + burstSpin;
          shape.position.z += 0.5 + burstStrength * 2;

          if (shape.position.z > 10) {
            shape.position.z = -500;
          }
        });

        torusKnot.scale.setScalar(1 + burstStrength * 0.6);
        torusKnot.material.emissiveIntensity = 0.5 + burstStrength;
        burstStrength = Math.max(0, burstStrength * 0.92 - 0.002);

        sparkleLayer.update(delta);
        ctx.toy.render();
      }

      function resize() {
        sparkleLayer.resize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener('resize', resize);
      resize();

      startAudioLoop(toy, animate).catch((err) => {
        console.error('The following error occurred: ' + err);
        displayError(
          'Microphone access is required for the visualization to work. Please allow microphone access.'
        );
      });
    </script>
  </body>
</html>
