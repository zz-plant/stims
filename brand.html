<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Enhanced Star Guitar Inspired Visualizer</title>
    <link rel="stylesheet" href="assets/css/base.css" />
  </head>
  <body>
    <a href="index.html" class="home-link">Back to Library</a>
    <script type="module">
      import * as THREE from 'three';
      import {
        initAudio,
        getFrequencyData,
      } from './assets/js/utils/audio-handler.ts';
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000000, 10, 200);

      // Camera setup
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 2, 5);
      camera.rotation.x = -0.05;

      // Renderer setup
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting setup
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffddaa, 0.8);
      directionalLight.position.set(0, 50, -50);
      scene.add(directionalLight);

      // Gradient Sky
      const skyGeo = new THREE.SphereGeometry(500, 32, 15);
      const skyMat = new THREE.ShaderMaterial({
        vertexShader: `
                varying vec2 vUV;
                void main() {
                    vUV = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
        fragmentShader: `
                varying vec2 vUV;
                void main() {
                    vec3 skyColor = mix(vec3(0.1, 0.2, 0.5), vec3(0.8, 0.9, 1.0), vUV.y);
                    gl_FragColor = vec4( skyColor, 1.0 );
                }
            `,
        side: THREE.BackSide,
      });
      const sky = new THREE.Mesh(skyGeo, skyMat);
      scene.add(sky);

      // Ground plane
      const groundGeo = new THREE.PlaneGeometry(1000, 1000);
      const groundMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1.5;
      scene.add(ground);

      // Function to create procedural elements
      const scenery = [];
      function createElement(type, x, z) {
        let element;
        const scaleFactor = Math.random() * 1.5 + 2;
        switch (type) {
          case 'building':
            element = new THREE.Mesh(
              new THREE.BoxGeometry(1, scaleFactor, 1),
              new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff })
            );
            break;
          case 'tree':
            const trunk = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, 1),
              new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            const leaves = new THREE.Mesh(
              new THREE.ConeGeometry(0.5, 1.5, 8),
              new THREE.MeshLambertMaterial({ color: 0x228b22 })
            );
            leaves.position.set(0, 0.5, 0);
            element = new THREE.Group();
            element.add(trunk);
            element.add(leaves);
            break;
          case 'pole':
            element = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, 5),
              new THREE.MeshLambertMaterial({ color: 0xaaaaaa })
            );
            break;
          default:
            element = new THREE.Mesh(
              new THREE.SphereGeometry(1, 32, 32),
              new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff })
            );
            break;
        }
        element.position.set(x, 0, z);
        scenery.push(element);
        scene.add(element);
      }

      // Populate scenery with varied elements
      for (let i = 0; i < 100; i++) {
        const z = -Math.random() * 300;
        const side = Math.random() > 0.5 ? 1 : -1;
        const x = side * (Math.random() * 10 + 5);
        const types = ['building', 'tree', 'pole'];
        const randomType = types[Math.floor(Math.random() * types.length)];
        createElement(randomType, x, z);
      }

      // Audio setup using shared utility
      let analyser;
      initAudio()
        .then(({ analyser: a }) => {
          analyser = a;
        })
        .catch((err) => {
          console.error('Audio input error: ', err);
        });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        let bass = 0;
        if (analyser) {
          const dataArray = getFrequencyData(analyser);
          bass = dataArray.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
        }

        const speed = 0.5 + bass / 100;
        scenery.forEach((obj) => {
          obj.position.z += speed;
          if (obj.position.z > 5) {
            obj.position.z -= 300;
            obj.position.x =
              (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 10 + 5);
          }
        });

        renderer.render(scene, camera);
      }

      animate();

      // Handle window resizing
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
