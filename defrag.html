<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Defrag Sound-Reactive Visualizer</title>
    <link rel="stylesheet" href="assets/css/base.css" />
    <style>
      body {
        background-color: #000000; /* OLED black */
        color: #00ff00; /* Old-school green text */
      }
      #statusIndicator {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        font-size: 16px;
      }
      #defragText {
        position: absolute;
        bottom: 10px;
        left: 10px;
        z-index: 10;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="home-link">Back to Library</a>
    <canvas id="canvas"></canvas>
    <div id="error-message" style="display: none"></div>
    <div id="statusIndicator" aria-live="polite"></div>
    <div id="defragText">Defragmenting Drive C:</div>

    <script type="module">
      import {
        initAudio,
        getAverageFrequency,
        getFrequencyData,
      } from './assets/js/utils/audio-handler.ts';
      import { showError } from './assets/js/utils/error-display.ts';
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      const rows = 30;
      const cols = 40;
      const blockWidth = canvas.width / cols;
      const blockHeight = canvas.height / rows;
      const blocks = [];
      let idleAnimationTime = 0.0; // Idle state timer for defragmentation effects
      let idleColorShift = 0;
      const DEFAULT_FFT_SIZE = 64;
      const neutralSpectrum = new Uint8Array(DEFAULT_FFT_SIZE / 2);

      // Initialize grid with random colors
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          blocks.push({
            x: j * blockWidth,
            y: i * blockHeight,
            color: `hsl(${Math.random() * 360}, 100%, 50%)`,
            sizeModifier: 1.0,
          });
        }
      }

      let analyser;
      let audioDataArray = neutralSpectrum.slice();
      let idleState = true;
      let movingAverageLevel = 0;
      const idleThreshold = 5;

      const statusIndicator = document.getElementById('statusIndicator');

      function updateStatusIndicator(state) {
        if (!statusIndicator) return;

        const messages = {
          waiting: 'Waiting for mic…',
          listening: 'Listening…',
          idle: 'Listening for sound…',
        };

        statusIndicator.textContent = messages[state] ?? '';
      }

      updateStatusIndicator('waiting');

      async function setupAudio() {
        try {
          const result = await initAudio({ fftSize: DEFAULT_FFT_SIZE });
          analyser = result.analyser;
          updateStatusIndicator('listening');
        } catch (err) {
          console.error('Error capturing audio: ', err);
          showError(
            'error-message',
            'Microphone access is required for the visualization to work. Please allow microphone access.'
          );
          updateStatusIndicator('waiting');
        }
      }

      function drawBlocks() {
        const frequencyData = audioDataArray.length
          ? audioDataArray
          : neutralSpectrum;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        blocks.forEach((block, index) => {
          const frequency = frequencyData[index % frequencyData.length] / 255.0; // Normalize frequency
          block.sizeModifier = frequency * 2; // Adjust block size based on frequency data

          if (idleState) {
            // If idle, perform defragmentation-style rearrangement of blocks
            idleAnimationTime += 0.005;
            const idleEffect = Math.sin(idleAnimationTime + index * 0.1);
            block.sizeModifier = 1.0 + idleEffect * 0.2; // Small fluctuations
            block.color = `hsl(${(idleColorShift + index) % 360}, 100%, 50%)`; // Gradual color shift
          } else {
            const colorMod = Math.floor(frequency * 360); // Adjust block color based on frequency data
            block.color = `hsl(${colorMod}, 100%, 50%)`;
          }

          const adjustedWidth = blockWidth * block.sizeModifier;
          const adjustedHeight = blockHeight * block.sizeModifier;

          ctx.fillStyle = block.color;
          ctx.fillRect(block.x, block.y, adjustedWidth, adjustedHeight);
        });

        idleColorShift += 1; // Slow color shift during idle state
      }

      function defragTextAnimation() {
        const text = document.getElementById('defragText');
        if (text.innerHTML.endsWith('...')) {
          text.innerHTML = 'Defragmenting Drive C:';
        } else {
          text.innerHTML += '.';
        }
      }

      function defragLoop() {
        if (analyser) {
          audioDataArray = getFrequencyData(analyser);
          const averageLevel = getAverageFrequency(audioDataArray);
          movingAverageLevel =
            movingAverageLevel * 0.7 + averageLevel * 0.3;
          idleState = movingAverageLevel < idleThreshold;
          updateStatusIndicator(idleState ? 'idle' : 'listening');
        } else {
          updateStatusIndicator('waiting');
        }
        drawBlocks();
        defragTextAnimation();
        requestAnimationFrame(defragLoop);
      }

      setupAudio();
      defragLoop();
    </script>
  </body>
</html>
