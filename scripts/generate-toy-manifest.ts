import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import { inspect } from 'node:util';
import { toyManifestSchema } from '../assets/js/data/toy-schema.ts';
import { loadToyRegistry } from './toy-registry.ts';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

const manifestPath = path.join(repoRoot, 'assets/js/data/toy-manifest.ts');
const publicPath = path.join(repoRoot, 'public/toys.json');

function formatZodIssues(error: {
  issues: { path: PropertyKey[]; message: string }[];
}) {
  return error.issues
    .map((issue) => {
      const pathLabel = issue.path.length
        ? issue.path
            .map((segment) =>
              typeof segment === 'symbol'
                ? segment.toString()
                : String(segment),
            )
            .join('.')
        : 'manifest';
      return `- ${pathLabel}: ${issue.message}`;
    })
    .join('\n');
}

function buildManifestSource(data: unknown, sourceLabel: string) {
  const parsed = toyManifestSchema.safeParse(data);
  if (!parsed.success) {
    const message = [
      `Toy manifest validation failed for ${sourceLabel}:`,
      formatZodIssues(parsed.error),
    ].join('\n');
    throw new Error(message);
  }

  return parsed.data;
}

function buildManifestModule(manifest: unknown) {
  const content = inspect(manifest, {
    depth: null,
    maxArrayLength: null,
    compact: false,
    breakLength: 80,
  });
  return `/* This file is auto-generated by scripts/generate-toy-manifest.ts. */\nimport type { ToyManifest } from './toy-schema.ts';\n\nexport const toyManifest: ToyManifest = ${content};\n\nexport default toyManifest;\n`;
}

async function writeManifestFiles(manifest: unknown) {
  await fs.mkdir(path.dirname(manifestPath), { recursive: true });
  await fs.writeFile(manifestPath, buildManifestModule(manifest), 'utf8');
  await fs.writeFile(publicPath, JSON.stringify(manifest, null, 2), 'utf8');
}

async function main() {
  const { entries, relativePath } = await loadToyRegistry(repoRoot);
  const manifest = buildManifestSource(entries, relativePath);
  await writeManifestFiles(manifest);
  console.log('Generated toy manifest at assets/js/data/toy-manifest.ts.');
  console.log('Updated public/toys.json for runtime fetch overrides.');
}

const argvPath = process.argv[1] ? path.resolve(process.argv[1]) : '';
if (argvPath && import.meta.url === pathToFileURL(argvPath).href) {
  await main();
}
