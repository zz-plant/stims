<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Word Cloud & Visualizer</title>
    <script src="assets/js/lib/wordcloud2.min.js"></script>
    <link rel="stylesheet" href="assets/css/base.css" />
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(135deg, #6a11cb, #2575fc);
        background-size: 400% 400%;
        animation: backgroundShift 10s ease infinite;
        position: relative;
      }

      @keyframes backgroundShift {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      #word-cloud-container {
        width: 80vw;
        height: 60vh;
        overflow: hidden;
        border-radius: 15px;
        background: rgba(255, 255, 255, 0.05);
        box-shadow: 0 12px 50px rgba(0, 0, 0, 0.3);
        position: absolute;
        top: 15%;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        mix-blend-mode: screen;
      }

      #word-cloud-canvas {
        width: 100%;
        height: 100%;
      }

      .control-panel {
        position: fixed;
        bottom: 4vh;
        left: 50%;
        transform: translateX(-50%);
        display: grid;
        gap: 8px;
        z-index: 15;
        text-align: center;
      }

      .controls {
        display: flex;
        gap: 20px;
        justify-content: center;
      }

      .control-button {
        background: rgba(255, 255, 255, 0.2);
        padding: 20px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: box-shadow 0.4s ease, transform 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1 / 1;
        overflow: hidden;
        position: relative;
      }

      .control-button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
      }

      .control-button.active {
        box-shadow: 0 0 60px rgba(255, 255, 255, 0.9);
        background-color: rgba(255, 255, 255, 0.3);
      }

      .control-button:active {
        transform: scale(0.9);
      }

      .control-icon {
        width: 35px;
        height: 35px;
        transition: filter 1.5s ease;
        filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.7));
      }

      .control-hint {
        color: rgba(255, 255, 255, 0.9);
        font-size: 0.95rem;
        text-shadow: 0 1px 6px rgba(0, 0, 0, 0.35);
        max-width: 520px;
        margin: 0 auto;
        line-height: 1.3;
      }

      .particle {
        position: absolute;
        border-radius: 50%;
        pointer-events: none;
        animation: particleFloat 4s ease-in-out infinite alternate;
        opacity: 0.8;
        z-index: 5;
        mix-blend-mode: difference;
      }

      @keyframes particleFloat {
        0% {
          transform: translateY(0) translateX(0) scale(1);
          opacity: 0.5;
        }
        50% {
          transform: translateY(-20px) translateX(20px) scale(1.3);
          opacity: 1;
        }
        100% {
          transform: translateY(-40px) translateX(-20px) scale(1);
          opacity: 0.5;
        }
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="home-link">Back to Library</a>
    <div class="control-panel">
      <div class="controls">
        <button
          id="unmute-button"
          class="control-button"
          aria-label="Unmute Visualizer"
          title="Toggle Visualizer"
        >
          <img
            id="unmute-icon"
            class="control-icon"
            src="./assets/ui/mic-off.svg"
            alt="Mic Access Icon"
          />
        </button>

        <button
          id="toggle-speech-button"
          class="control-button"
          aria-label="Speech Recognition"
          title="Toggle Speech Recognition"
        >
          <img
            id="toggle-speech-icon"
            class="control-icon"
            src="./assets/ui/speech-off.svg"
            alt="Add Word Icon"
          />
        </button>
      </div>
      <p class="control-hint">
        Unmute to sync the visuals with your microphone. Enable speech to drop your spoken words into the cloudâ€”if your browser supports it.
      </p>
    </div>

    <div id="word-cloud-container">
      <canvas id="word-cloud-canvas"></canvas>
      <div id="error-message" style="display: none"></div>
    </div>

    <script type="module">
      import { initAudio, getFrequencyData } from './assets/js/utils/audio-handler.ts';
      import { startToyAudio } from './assets/js/utils/start-audio.ts';
      import { showError } from './assets/js/utils/error-display.ts';
      const wordCloudCanvas = document.getElementById('word-cloud-canvas');
      const unmuteButton = document.getElementById('unmute-button');
      const toggleSpeechButton = document.getElementById(
        'toggle-speech-button'
      );
      const unmuteIcon = document.getElementById('unmute-icon');
      const toggleSpeechIcon = document.getElementById('toggle-speech-icon');
      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition;
      const speechSupported = Boolean(SpeechRecognition);
      let recognition = null;

      const seedWords = [
        'pulse',
        'color',
        'flow',
        'echo',
        'harmony',
        'spark',
        'glow',
        'breathe',
        'calm',
        'wave',
        'rhythm',
      ];

      class AudioToy {
        constructor() {
          this.analyser = null;
          this.audioCleanup = null;
          this.loopId = null;
          this.renderLoop = null;
          this.renderer = {
            setAnimationLoop: (loop) => {
              if (this.loopId) {
                cancelAnimationFrame(this.loopId);
              }

              this.renderLoop = loop;

              if (!loop) return;

              const tick = () => {
                this.renderLoop?.();
                this.loopId = requestAnimationFrame(tick);
              };

              tick();
            },
          };
        }

        async initAudio(options = {}) {
          const audio = await initAudio(options);
          this.analyser = audio.analyser;
          this.audioCleanup = audio.cleanup;
          return audio;
        }

        dispose() {
          if (this.loopId) {
            cancelAnimationFrame(this.loopId);
          }

          this.renderLoop = null;
          this.loopId = null;
          this.audioCleanup?.();
          this.analyser = null;
        }
      }

      let toy = null;

      let isUnmuted = false;
      let isAddingWords = false;
      let wordsArray = [...seedWords];
      let wordCloudData = [];

      // Word cloud shapes for randomness
      const shapes = ['circle', 'star', 'triangle', 'diamond'];

      const speechUnavailableMessage =
        'Speech recognition is unavailable. Words will stay on the default seed set unless you add more manually in a supported browser.';

      function updateUnmuteIcon() {
        unmuteIcon.src = isUnmuted
          ? './assets/ui/mic-on.svg'
          : './assets/ui/mic-off.svg';
      }

      function updateSpeechIcon() {
        toggleSpeechIcon.src = isAddingWords
          ? './assets/ui/speech-on.svg'
          : './assets/ui/speech-off.svg';
      }

      function disableSpeechToggle(message) {
        isAddingWords = false;
        toggleSpeechButton.classList.remove('active');
        toggleSpeechButton.disabled = true;
        toggleSpeechButton.title = message;
        updateSpeechIcon();
        showError('error-message', message);
      }

      function initSpeechRecognition() {
        if (!speechSupported) {
          disableSpeechToggle(speechUnavailableMessage);
          return;
        }

        recognition = new SpeechRecognition();
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
      }

      function updateWordCloud(words) {
        if (WordCloud.isSupported) {
          const wordFrequency = words.reduce((freq, word) => {
            freq[word] = (freq[word] || 0) + 1;
            return freq;
          }, {});

          wordCloudData = Object.entries(wordFrequency).map(([word, count]) => [
            word,
            count,
          ]);

          const randomShape = shapes[Math.floor(Math.random() * shapes.length)];

          WordCloud(wordCloudCanvas, {
            list: wordCloudData,
            gridSize: Math.floor(10 * (window.innerWidth / 1024)),
            weightFactor: 15,
            color: () => `hsl(${Math.random() * 360}, 100%, 50%)`,
            rotateRatio: 0.4,
            minRotation: -Math.PI / 6,
            maxRotation: Math.PI / 6,
            backgroundColor: 'transparent',
            shape: randomShape,
            drawOutOfBound: false,
            shrinkToFit: true,
            clearCanvas: true,
          });
        }
      }

      // Unmute button logic for music visualizer activation
      unmuteButton.addEventListener('click', () => {
        if (!isUnmuted) {
          isUnmuted = true;
          unmuteButton.classList.add('active');
          updateUnmuteIcon();
          deactivateSpeechRecognition(); // Ensure speech recognition is turned off before starting visualizer
          activateVisualizer();
        } else {
          isUnmuted = false;
          unmuteButton.classList.remove('active');
          updateUnmuteIcon();
          deactivateVisualizer();
        }
      });

      async function activateVisualizer() {
        try {
          toy = toy ?? new AudioToy();
          await startToyAudio(toy, animate, { fallbackToSynthetic: true });
        } catch (error) {
          console.error('Error accessing microphone for visualizer:', error);
          showError(
            'error-message',
            'Microphone access is required for the visualization to work. Please allow microphone access.'
          );
          isUnmuted = false;
          unmuteButton.classList.remove('active');
          updateUnmuteIcon();
          deactivateVisualizer();
        }
      }

      function animate(ctxAudio) {
        if (!isUnmuted) return;

        const dataArray = ctxAudio.analyser
          ? getFrequencyData(ctxAudio.analyser)
          : new Uint8Array(0);
        const maxVolume = dataArray.length ? Math.max(...dataArray) : 0;

        updateWordCloudWithVisualizer(maxVolume);
        createParticleEffects(maxVolume);
      }

      function deactivateVisualizer() {
        toy?.dispose();
        toy = null;
        document.querySelectorAll('.particle').forEach((p) => p.remove());
      }

      function updateWordCloudWithVisualizer(volume) {
        if (WordCloud.isSupported && wordCloudData.length) {
          WordCloud(wordCloudCanvas, {
            list: wordCloudData.map(([word, count]) => [
              word,
              count * (1 + volume / 256),
            ]),
            gridSize: Math.floor(10 * (window.innerWidth / 1024)),
            weightFactor: 15,
            color: () =>
              `hsl(${Math.random() * 360}, 100%, ${50 + volume / 10}%)`,
            rotateRatio: 0.4,
            minRotation: -Math.PI / 6,
            maxRotation: Math.PI / 6,
            backgroundColor: 'transparent',
            shape: 'circle',
            drawOutOfBound: false,
            shrinkToFit: true,
            clearCanvas: true,
          });
        }
      }

      function createParticleEffects(volume) {
        document.querySelectorAll('.particle').forEach((p) => p.remove());
        const particleCount = Math.min(volume / 10, 10);

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.width = `${Math.random() * 8 + 3}px`;
          particle.style.height = particle.style.width;
          particle.style.left = `${Math.random() * 90}vw`;
          particle.style.top = `${Math.random() * 80}vh`;
          particle.style.background = `hsl(${Math.random() * 360}, 100%, 75%)`;
          document.body.appendChild(particle);
        }
      }

      // Toggle speech button logic for speech detection
      toggleSpeechButton.addEventListener('click', () => {
        if (!recognition) {
          disableSpeechToggle(speechUnavailableMessage);
          return;
        }

        if (!isAddingWords) {
          isAddingWords = true;
          toggleSpeechButton.classList.add('active');
          updateSpeechIcon();
          deactivateVisualizer(); // Ensure visualizer is turned off before starting speech recognition
          try {
            recognition.start();
          } catch (error) {
            console.error('Unable to start speech recognition:', error);
            disableSpeechToggle(
              'Speech recognition could not start. Please check your permissions and try again.'
            );
          }
        } else {
          isAddingWords = false;
          toggleSpeechButton.classList.remove('active');
          updateSpeechIcon();
          recognition.stop();
        }
      });

      function deactivateSpeechRecognition() {
        if (isAddingWords && recognition) {
          isAddingWords = false;
          toggleSpeechButton.classList.remove('active');
          updateSpeechIcon();
          recognition.stop();
        }
      }

      initSpeechRecognition();

      if (recognition) {
        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          const newWords = transcript.split(' ');

          wordsArray = wordsArray.concat(newWords);

          if (wordsArray.length > 1000) {
            wordsArray = wordsArray.slice(wordsArray.length - 1000);
          }

          updateWordCloud(wordsArray);
        };

        recognition.onspeechend = () => {
          if (isAddingWords) {
            recognition.start(); // Keep listening as long as the toggle is active
          } else {
            recognition.stop();
          }
        };

        recognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);

          if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
            disableSpeechToggle(
              'Speech recognition permission was denied. You can keep using the default word cloud.'
            );
            return;
          }

          if (isAddingWords) {
            recognition.start();
          }
        };
      }

      // Initial word cloud rendering for visibility testing
      updateUnmuteIcon();
      updateSpeechIcon();
      updateWordCloud(wordsArray);
    </script>
  </body>
</html>
