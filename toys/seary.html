<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Trippy Synesthetic Visualizer with WebGL</title>
    <link rel="stylesheet" href="../assets/css/base.css" />
    <style>
      body,
      html {
        height: 100%;
        background-color: #000000; /* OLED black */
      }
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }
      #sparkleCanvas {
        pointer-events: none;
        mix-blend-mode: screen;
        z-index: 5;
      }
    </style>
  </head>
  <body>
    <a href="../index.html" class="home-link">Back to Library</a>
    <canvas id="gpuCanvas" class="toy-canvas"></canvas>
    <canvas id="sparkleCanvas" class="toy-canvas"></canvas>
    <div id="error-message" style="display: none"></div>
    <div class="control-panel" aria-label="Audio controls">
      <div class="control-panel__heading">Audio Input</div>
      <div class="control-panel__row">
        <label class="control-panel__label" for="audioSelect">Source</label>
        <select id="audioSelect">
          <option value="mic">Microphone</option>
          <option value="device">Device Audio</option>
        </select>
      </div>
    </div>
    <script type="module">
      import {
        getFrequencyData,
        initAudio,
      } from '../assets/js/utils/audio-handler.ts';
      import { setupCanvasResize } from '../assets/js/utils/canvas-resize.ts';
      import { showError } from '../assets/js/utils/error-display.ts';
      import { createPeakDetector } from '../assets/js/utils/peak-detector.ts';
      import { startToyAudio } from '../assets/js/utils/start-audio.ts';
      import { createSearyFunAdapter } from '../assets/seary/fun-adapter.ts';
      import { initFunControls } from '../assets/ui/fun-controls.ts';
      import { initHints } from '../assets/ui/hints.ts';
      import { createUnifiedInput } from '../assets/js/utils/unified-input.ts';
      import {
        getBandLevels,
        getWeightedEnergy,
        updateEnergyPeak,
      } from '../assets/js/utils/audio-reactivity.ts';

      // Fallback to WebGL
      const canvas = document.getElementById('gpuCanvas');
      const sparkleCanvas = document.getElementById('sparkleCanvas');
      const sparkleCtx = sparkleCanvas?.getContext('2d');

      const sparkles = [];
      const maxSparkles = 160;
      const burstState = { scale: 1, rotation: 0, intensity: 0 };
      let viewWidth = window.innerWidth;
      let viewHeight = window.innerHeight;
      let sparklesEnabled = true;
      let burstsEnabled = true;
      let peakSensitivity = 0.35;
      let lastRenderTime = 0;
      let renderElapsed = 0;

      function displayError(message) {
        const el = document.getElementById('error-message');
        if (el) {
          el.innerText = message;
          el.style.display = 'block';
        }
      }

      initHints({
        id: 'seary-visualizer',
        tips: [
          'Play music or tap to trigger sparkles.',
          'Switch to Party Mode for bigger motion.',
          'Use the audio source menu to swap between mic and device audio.',
        ],
      });

      const adapter = createSearyFunAdapter();
      let peakDetector = null;
      let lastVibrateTime = 0;
      let energyPeak = 0.12;
      let bassPulse = 0;
      let trebleShimmer = 0;
      let currentFreqs = adapter.transformFrequencies({
        low: 0,
        mid: 0,
        high: 0,
      });
      const audioSelect = document.getElementById('audioSelect');
      const funControls = initFunControls({
        paletteOptions: adapter.paletteOptions,
        onPaletteChange: (palette, colors) =>
          adapter.setPalette(palette, colors),
        onMotionChange: (intensity, mode) => adapter.setMotion(intensity, mode),
        onAudioToggle: (enabled) => adapter.setAudioReactive(enabled),
        onSparkleToggle: (enabled) => {
          sparklesEnabled = enabled;
        },
        onBurstToggle: (enabled) => {
          burstsEnabled = enabled;
          if (!enabled) {
            burstState.scale = 1;
            burstState.rotation = 0;
            burstState.intensity = 0;
          }
        },
        onPeakSensitivityChange: (value) => {
          peakSensitivity = value;
          rebuildPeakDetector();
        },
        initialSparklesEnabled: sparklesEnabled,
        initialBurstsEnabled: burstsEnabled,
        initialPeakSensitivity: peakSensitivity,
      });

      const gl =
        canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

      if (!gl) {
        console.error('WebGL not supported');
        throw new Error('WebGL not supported');
      }

      // Resize canvas
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        viewWidth = window.innerWidth;
        viewHeight = window.innerHeight;

        canvas.width = viewWidth * dpr;
        canvas.height = viewHeight * dpr;
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
        gl.viewport(0, 0, canvas.width, canvas.height);

        if (sparkleCanvas && sparkleCtx) {
          sparkleCanvas.width = viewWidth * dpr;
          sparkleCanvas.height = viewHeight * dpr;
          sparkleCanvas.style.width = '100vw';
          sparkleCanvas.style.height = '100vh';
          sparkleCtx.setTransform(1, 0, 0, 1, 0, 0);
          sparkleCtx.scale(dpr, dpr);
        }
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      const disposeResize = setupCanvasResize(canvas, gl, { maxPixelRatio: 2 });

      class CanvasToy {
        constructor(canvasEl) {
          this.canvas = canvasEl;
          this.analyser = null;
          this.audioCleanup = null;
          this.loopId = null;
          this.renderLoop = null;
          this.renderer = {
            setAnimationLoop: (loop) => {
              if (this.loopId) {
                cancelAnimationFrame(this.loopId);
              }

              this.renderLoop = loop;

              if (!loop) return;

              const tick = () => {
                this.renderLoop?.();
                this.loopId = requestAnimationFrame(tick);
              };

              tick();
            },
          };
        }

        async initAudio(options = {}) {
          const audio = await initAudio(options);
          this.analyser = audio.analyser;
          this.audioCleanup = audio.cleanup;
          return audio;
        }

        dispose() {
          if (this.loopId) {
            cancelAnimationFrame(this.loopId);
          }

          this.renderLoop = null;
          this.loopId = null;
          this.audioCleanup?.();
          this.analyser = null;
        }
      }

      const toy = new CanvasToy(canvas);

      // Compile shader
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            'Shader compile failed: ' + gl.getShaderInfoLog(shader)
          );
          gl.deleteShader(shader);
          throw new Error('Shader compile error');
        }
        return shader;
      }

      // Vertex shader source
      const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

      // Fragment shader source
      const fragmentShaderSource = `
            precision mediump float;
            uniform float u_time;
            uniform float u_low_freq;
            uniform float u_mid_freq;
            uniform float u_high_freq;
            uniform vec2 u_touch0;
            uniform vec2 u_touch1;
            uniform vec3 u_orientation;
            uniform vec3 u_palette_accent;
            uniform float u_burst_scale;
            uniform float u_burst_rotation;
            uniform float u_burst_intensity;
            varying vec2 v_uv;
            
            float noise(vec2 p) {
                return sin(p.x * 12.9898 + p.y * 78.233) * 43758.5453 - floor(sin(p.x * 12.9898 + p.y * 78.233) * 43758.5453);
            }

            void main() {
                vec2 uv = v_uv - 0.5;
                float c = cos(u_burst_rotation);
                float s = sin(u_burst_rotation);
                uv = mat2(c, -s, s, c) * uv * u_burst_scale;
                float dist = length(uv);
                float angle = atan(uv.y, uv.x);

                // Background color shifting and dynamic gradients
                vec3 baseColor = vec3(
                    0.5 + 0.5 * sin(u_time + angle + u_low_freq * 5.0),
                    0.5 + 0.5 * cos(u_time + angle * 2.0 + u_mid_freq * 3.0),
                    0.5 + 0.5 * sin(u_time * 0.5 + angle * 3.0 + u_high_freq * 7.0)
                );

                // Low frequency pulsing waves
                float lowWave = 0.5 + 0.5 * sin(15.0 * dist - u_time + angle * 3.0) * (u_low_freq + 0.3);
                vec3 lowColor = vec3(lowWave * 0.5, lowWave * 0.3, lowWave);

                // Mid frequency oscillations with noise distortion
                float midOscillation = 0.5 + 0.5 * cos(20.0 * dist - u_time * 1.5 + angle * 4.0) * (u_mid_freq + 0.4);
                midOscillation += noise(uv * 10.0) * 0.2 * u_mid_freq;
                vec3 midColor = vec3(midOscillation * 0.3, midOscillation, midOscillation * 0.6);

                // High frequency sparks with strobe effect
                float highSpark = 0.5 + 0.5 * sin(25.0 * dist - u_time * 2.0 + angle * 6.0) * (u_high_freq + 0.5);
                highSpark += step(0.9, fract(sin(u_time * 10.0) * 43758.5453)) * 0.3 * u_high_freq;
                vec3 highColor = vec3(highSpark, highSpark * 0.5, highSpark * 0.2);

                // Blend low, mid, and high colors together for synesthetic experience
                vec3 color = baseColor + lowColor + midColor + highColor;

                // Add ripple effects from multi-touch interactions
                float touchEffect0 = 0.0;
                float touchEffect1 = 0.0;
                if (length(u_touch0) > 0.0) {
                    touchEffect0 = 0.2 / length(uv - (u_touch0 - 0.5));
                }
                if (length(u_touch1) > 0.0) {
                    touchEffect1 = 0.2 / length(uv - (u_touch1 - 0.5));
                }
                color += vec3(touchEffect0 + touchEffect1);

                // Orientation-based distortion to make visuals more fluid and trippy
                float orientationEffect = sin(u_orientation.x * uv.x * 10.0 + u_time) * 0.1 * u_orientation.y;
                uv += vec2(orientationEffect, orientationEffect);

                // Kaleidoscope-like radial gradient with more vivid effects
                float radialGradient = smoothstep(0.6, 0.0, dist) * (1.0 + sin(u_time * 5.0 + dist * 15.0) * 0.1);
                color *= radialGradient;

                // Add more glow and blur for a dreamy, synesthetic feel
                float glow = exp(-10.0 * dist) * (u_low_freq + u_mid_freq + u_high_freq);
                color += vec3(glow * 0.4, glow * 0.6, glow * 0.8);

                color = mix(color, color * u_palette_accent, 0.35);
                color *= 1.0 + u_burst_intensity * 0.6;
                color += u_palette_accent * (u_burst_intensity * 0.25);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

      // Create and link program
      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(
        fragmentShaderSource,
        gl.FRAGMENT_SHADER
      );
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link failed: ' + gl.getProgramInfoLog(program));
        throw new Error('Program link error');
      }
      gl.useProgram(program);

      // Set up geometry
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
        gl.STATIC_DRAW
      );

      const positionLocation = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      // Set up uniforms
      const timeLocation = gl.getUniformLocation(program, 'u_time');
      const lowFreqLocation = gl.getUniformLocation(program, 'u_low_freq');
      const midFreqLocation = gl.getUniformLocation(program, 'u_mid_freq');
      const highFreqLocation = gl.getUniformLocation(program, 'u_high_freq');
      const touch0Location = gl.getUniformLocation(program, 'u_touch0');
      const touch1Location = gl.getUniformLocation(program, 'u_touch1');
      const orientationLocation = gl.getUniformLocation(
        program,
        'u_orientation'
      );
      const paletteLocation = gl.getUniformLocation(
        program,
        'u_palette_accent'
      );
      const burstScaleLocation = gl.getUniformLocation(
        program,
        'u_burst_scale'
      );
      const burstRotationLocation = gl.getUniformLocation(
        program,
        'u_burst_rotation'
      );
      const burstIntensityLocation = gl.getUniformLocation(
        program,
        'u_burst_intensity'
      );

      const orientation = { alpha: 0, beta: 0, gamma: 0 };
      const touches = [
        { x: 0.0, y: 0.0 },
        { x: 0.0, y: 0.0 },
      ];
      const unifiedInput = createUnifiedInput({
        target: canvas,
        boundsElement: canvas,
        onInput: (state) => {
          for (let i = 0; i < touches.length; i++) {
            const pointer = state.pointers[i];
            if (pointer) {
              touches[i].x = pointer.normalizedX;
              touches[i].y = pointer.normalizedY;
            } else {
              touches[i].x = 0.0;
              touches[i].y = 0.0;
            }
          }

          if (state.justPressed && state.primary) {
            spawnSparkles(18, {
              x: state.primary.clientX,
              y: state.primary.clientY,
            });
          }
        },
      });

      function spawnSparkles(count = 26, origin) {
        if (!sparklesEnabled || !sparkleCtx) return;
        const baseX = origin?.x ?? Math.random() * viewWidth;
        const baseY = origin?.y ?? Math.random() * viewHeight;

        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 40 + Math.random() * 120;
          const hue = Math.floor(Math.random() * 360);
          sparkles.push({
            x: baseX,
            y: baseY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0,
            maxLife: 0.6 + Math.random() * 0.5,
            size: 1.5 + Math.random() * 2.5,
            hue,
          });
        }

        if (sparkles.length > maxSparkles) {
          sparkles.splice(0, sparkles.length - maxSparkles);
        }
      }

      function updateSparkles(dt) {
        if (!sparkleCtx) return;
        if (!sparklesEnabled) {
          sparkleCtx.clearRect(0, 0, viewWidth, viewHeight);
          return;
        }
        sparkleCtx.clearRect(0, 0, viewWidth, viewHeight);

        for (let i = sparkles.length - 1; i >= 0; i--) {
          const s = sparkles[i];
          s.life += dt;
          if (s.life >= s.maxLife) {
            sparkles.splice(i, 1);
            continue;
          }

          const lifeT = s.life / s.maxLife;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          s.vx *= 0.98;
          s.vy *= 0.98;

          const alpha = 1 - lifeT;
          const radius = s.size * (1 + lifeT * 1.2);
          sparkleCtx.fillStyle = `hsla(${s.hue}, 85%, 70%, ${alpha})`;
          sparkleCtx.beginPath();
          sparkleCtx.arc(s.x, s.y, radius, 0, Math.PI * 2);
          sparkleCtx.fill();
        }
      }

      function handlePeak() {
        spawnSparkles(36);
        if (burstsEnabled) {
          burstState.scale = Math.min(burstState.scale + 0.2, 1.5);
          burstState.rotation += (Math.random() - 0.5) * 0.7;
          burstState.intensity = Math.min(1, burstState.intensity + 0.85);
        }
      }

      function handlePeakRelease() {
        burstState.intensity *= 0.5;
      }

      // Audio setup for beat detection and frequency analysis

      function vibrateBasedOnAudio(lowFreq, midFreq, highFreq) {
        const intensity = Math.max(lowFreq, midFreq, highFreq);
        const currentTime = Date.now();

        if (intensity > 0.7 && currentTime - lastVibrateTime > 500) {
          if (navigator.vibrate) {
            navigator.vibrate([intensity * 100, 50, intensity * 100]);
          }
          lastVibrateTime = currentTime;
        }
      }

      function vibrateBasedOnVisuals(lowFreq, midFreq, highFreq, dist) {
        const vibrateIntensity =
          Math.max(lowFreq, midFreq, highFreq) * (1.0 - dist);
        if (navigator.vibrate && vibrateIntensity > 0.5) {
          navigator.vibrate([
            Math.floor(vibrateIntensity * 200),
            50,
            Math.floor(vibrateIntensity * 200),
          ]);
        }
      }

      function rebuildPeakDetector(ctx) {
        const analyserNode = ctx?.analyser;
        if (!analyserNode) {
          peakDetector = null;
          return;
        }

        peakDetector = createPeakDetector({
          getData: () => getFrequencyData(analyserNode),
          sensitivity: peakSensitivity,
          onPeak: handlePeak,
          onRelease: handlePeakRelease,
        });
      }

      window.addEventListener('deviceorientation', (event) => {
        orientation.alpha = event.alpha;
        orientation.beta = event.beta;
        orientation.gamma = event.gamma;
      });

      function processAudio(ctxAudio) {
        if (!ctxAudio.analyser) {
          peakDetector = null;
          currentFreqs = adapter.transformFrequencies({
            low: 0,
            mid: 0,
            high: 0,
          });
          return { lowFreq: 0, midFreq: 0, highFreq: 0 };
        }

        const dataArray = getFrequencyData(ctxAudio.analyser);
        const bands = getBandLevels({
          analyser: ctxAudio.analyser,
          data: dataArray,
          ratios: { bass: 0.2, mid: 0.55 },
        });
        const weightedEnergy = getWeightedEnergy(bands);
        energyPeak = updateEnergyPeak(energyPeak, weightedEnergy);
        bassPulse = Math.max(bassPulse * 0.85, bands.bass);
        trebleShimmer = Math.max(trebleShimmer * 0.8, bands.treble);
        const boost = 0.75 + weightedEnergy * 0.9 + bassPulse * 0.6;
        const lowFreq = Math.min(1, bands.bass * boost);
        const midFreq = Math.min(1, bands.mid * (0.85 + boost * 0.6));
        const highFreq = Math.min(1, bands.treble * (0.9 + boost * 0.75));

        currentFreqs = adapter.transformFrequencies({
          low: lowFreq,
          mid: midFreq,
          high: highFreq,
        });

        if (!peakDetector) {
          rebuildPeakDetector(ctxAudio);
        }

        peakDetector?.update(dataArray);

        vibrateBasedOnAudio(
          currentFreqs.low,
          currentFreqs.mid,
          currentFreqs.high
        );
        vibrateBasedOnVisuals(
          currentFreqs.low,
          currentFreqs.mid,
          currentFreqs.high,
          Math.random()
        );

        return { lowFreq, midFreq, highFreq };
      }

      async function initializeAudio() {
        lastRenderTime = 0;
        renderElapsed = 0;
        const options =
          audioSelect.value === 'device'
            ? { preferSynthetic: true, fftSize: 256 }
            : { fftSize: 256, fallbackToSynthetic: true };

        try {
          await startToyAudio(toy, animate, options);
          funControls.setAudioAvailable(true);
          rebuildPeakDetector(toy);
        } catch (err) {
          console.error('Error accessing microphone: ' + err);
          funControls.setAudioAvailable(false);
          peakDetector = null;
          currentFreqs = adapter.transformFrequencies({
            low: 0,
            mid: 0,
            high: 0,
          });
          showError(
            'error-message',
            'Microphone access is required for the visualization to work. Please allow microphone access.'
          );
          toy.renderer.setAnimationLoop(() => animate({ toy, analyser: null }));
        }
      }

      audioSelect.addEventListener('change', initializeAudio);
      initializeAudio();

      // Render loop
      function animate(ctxAudio) {
        const now = performance.now();
        const delta = lastRenderTime === 0 ? 0 : (now - lastRenderTime) / 1000;
        const dt = Math.min(delta, 0.1);
        lastRenderTime = now;
        renderElapsed += dt;

        const audioMetrics = processAudio(ctxAudio);

        if (audioMetrics?.lowFreq > 0.5) {
          canvas.style.transform = 'scale(1.1)';
          setTimeout(() => {
            canvas.style.transform = 'scale(1)';
          }, 100);
        }

        bassPulse *= 0.9;
        trebleShimmer *= 0.9;

        burstState.scale += (1 - burstState.scale) * Math.min(1, dt * 2.25);
        burstState.rotation *= Math.max(0, 1 - dt * 1.35);
        burstState.intensity = Math.max(0, burstState.intensity - dt * 1.2);

        // Set uniforms
        gl.uniform1f(timeLocation, renderElapsed);
        gl.uniform1f(lowFreqLocation, currentFreqs.low);
        gl.uniform1f(midFreqLocation, currentFreqs.mid);
        gl.uniform1f(highFreqLocation, currentFreqs.high);
        gl.uniform3f(
          orientationLocation,
          orientation.alpha / 360.0,
          orientation.beta / 90.0,
          orientation.gamma / 90.0
        );
        gl.uniform2f(touch0Location, touches[0].x, touches[0].y);
        gl.uniform2f(touch1Location, touches[1].x, touches[1].y);
        gl.uniform3f(
          paletteLocation,
          adapter.paletteAccent[0],
          adapter.paletteAccent[1],
          adapter.paletteAccent[2]
        );
        gl.uniform1f(burstScaleLocation, burstsEnabled ? burstState.scale : 1);
        gl.uniform1f(
          burstRotationLocation,
          burstsEnabled ? burstState.rotation : 0
        );
        gl.uniform1f(
          burstIntensityLocation,
          burstsEnabled ? burstState.intensity : 0
        );

        // Draw
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        updateSparkles(dt || 0.016);
      }

      window.addEventListener('pagehide', () => {
        disposeResize();
        unifiedInput.dispose();
        toy.dispose?.();
      });
    </script>
  </body>
</html>
