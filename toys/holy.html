<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Ultimate Satisfying Audio Visualizer</title>
    <link rel="stylesheet" href="../assets/css/base.css" />
    <style>
      body {
        background-color: black;
      }
      #startButton,
      #infoButton,
      #settingsButton,
      #fullscreenButton {
        position: absolute;
        padding: 10px 18px;
        font-size: 15px;
        background-color: rgba(76, 175, 80, 0.7);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition:
          background-color 0.3s,
          transform 0.2s,
          box-shadow 0.3s;
        z-index: 10;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
      }
      #startButton:hover,
      #infoButton:hover,
      #settingsButton:hover,
      #fullscreenButton:hover {
        background-color: rgba(76, 175, 80, 1);
        transform: scale(1.05);
      }
      #startButton {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      #infoButton {
        top: 15px;
        right: 15px;
        width: 34px;
        height: 34px;
        border-radius: 50%;
        font-size: 18px;
        padding: 0;
      }
      #settingsButton {
        top: 15px;
        left: 15px;
        width: 34px;
        height: 34px;
        border-radius: 50%;
        font-size: 18px;
        padding: 0;
      }
      #fullscreenButton {
        top: 15px;
        right: 65px;
        width: 34px;
        height: 34px;
        border-radius: 50%;
        font-size: 16px;
        padding: 0;
      }
      #infoPanel,
      #settingsPanel {
        position: absolute;
        top: 70px;
        right: 15px;
        left: 15px;
        background-color: rgba(0, 0, 0, 0.78);
        color: white;
        padding: 20px;
        border-radius: 8px;
        display: none;
        z-index: 9;
        max-height: 80vh;
        overflow-y: auto;
      }
      #microHint {
        position: absolute;
        left: 50%;
        bottom: 24px;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 10px 16px;
        border-radius: 999px;
        font-size: 14px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 12;
      }
      #microHint.is-visible {
        opacity: 1;
      }
      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .panel-header h2 {
        margin: 0;
        font-size: 20px;
      }
      .closeButton {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
      }
      /* Loading Spinner */
      #loadingOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 20;
        flex-direction: column;
        color: white;
        font-size: 18px;
      }
      .spinner {
        border: 8px solid #f3f3f3;
        border-top: 8px solid #4caf50;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      /* Settings Panel */
      .slider-container {
        margin: 15px 0;
      }
      .slider-container label {
        display: block;
        margin-bottom: 5px;
      }
      .slider-container input {
        width: 100%;
      }
      #error-message {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #ff0000;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div data-toy-nav></div>
    <div id="error-message" style="display: none"></div>
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div>Initializing Visualizer...</div>
    </div>

    <!-- Control Buttons -->
    <button id="startButton">Start Visualizer</button>
    <button id="infoButton" aria-label="Open help panel" title="Help">?</button>
    <button id="settingsButton" aria-label="Open settings panel" title="Settings">⚙️</button>
    <button id="fullscreenButton" aria-label="Toggle fullscreen" title="Fullscreen">⛶</button>

    <!-- Info Panel -->
    <div id="infoPanel" role="dialog" aria-label="How to use" aria-hidden="true">
      <div class="panel-header">
        <h2>How to Use</h2>
        <button id="closeInfoButton" class="closeButton">×</button>
      </div>
      <p>Short on time? Try the basics below.</p>
      <details>
        <summary>Quick controls</summary>
        <p><strong>Drag:</strong> Rotate the visualizer.</p>
        <p><strong>Pinch:</strong> Zoom in and out.</p>
        <p><strong>Double Tap:</strong> Change shape.</p>
      </details>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel" role="dialog" aria-label="Settings" aria-hidden="true">
      <div class="panel-header">
        <h2>Settings</h2>
        <button id="closeSettingsButton" class="closeButton">×</button>
      </div>
      <div class="slider-container">
        <label for="particleCount"
          >Particle Count: <span id="particleCountValue">600</span></label
        >
        <input
          type="range"
          id="particleCount"
          min="100"
          max="2000"
          value="600"
        />
      </div>
      <div class="slider-container">
        <label for="shapeDetail"
          >Shape Detail: <span id="shapeDetailValue">32</span></label
        >
        <input
          type="range"
          id="shapeDetail"
          min="8"
          max="64"
          step="2"
          value="32"
        />
      </div>
      <div class="slider-container">
        <label for="opacity"
          >Shape Opacity: <span id="opacityValue">0.8</span></label
        >
        <input
          type="range"
          id="opacity"
          min="0.1"
          max="1"
          step="0.1"
          value="0.8"
        />
      </div>
      <div class="slider-container">
        <label for="bloomStrength"
          >Bloom Strength: <span id="bloomStrengthValue">1.5</span></label
        >
        <input
          type="range"
          id="bloomStrength"
          min="0.2"
          max="2.5"
          step="0.1"
          value="1.5"
        />
      </div>
      <div class="slider-container">
        <label for="particleScale"
          >Particle Size: <span id="particleScaleValue">1.0</span></label
        >
        <input
          type="range"
          id="particleScale"
          min="0.5"
          max="2"
          step="0.1"
          value="1"
        />
      </div>
      <div class="slider-container">
        <button id="surpriseButton" type="button">Surprise mix</button>
      </div>
    </div>
    <div id="microHint" role="status" aria-live="polite"></div>

    <!-- Main Visualizer Script -->
    <script type="module">
      import * as THREE from 'three';
      import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
      import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
      import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
      import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
      import {
        getFrequencyData,
      } from '../assets/js/utils/audio-handler.ts';
      import {
        getBandLevels,
        getWeightedEnergy,
        updateEnergyPeak,
      } from '../assets/js/utils/audio-reactivity.ts';
      import {
        initErrorDisplay,
        setErrorVisible,
      } from '../assets/js/utils/error-display.ts';
      import { createToyAudioBootstrap } from '../assets/js/utils/toy-audio-bootstrap.ts';
      import { initToyPageShell } from '../assets/js/utils/toy-page-shell.ts';
      import { createUnifiedInput } from '../assets/js/utils/unified-input.ts';
      import { ensureWebGL } from '../assets/js/utils/webgl-check.ts';

      initToyPageShell();

      if (!ensureWebGL()) {
        throw new Error('WebGL support is required for the Holy visualizer.');
      }
      let scene, camera, renderer, composer, bloomPass, fxaaPass;
      let visualizerShape, particles;
      let dataArray = new Uint8Array(0);
      let analyser = null;
      let sampleRate = 44100;
      let lastTap = 0;
      let zoomDistance = 5;
      const shapes = ['sphere', 'cube', 'torus', 'dodecahedron'];
      let currentShape = 0;
      let particleCount = 600;
      let shapeDetail = 32;
      let shapeOpacity = 0.8;
      let bloomStrength = 1.5;
      let particleScale = 1;
      let instancedParticles;
      let particleMaterial;
      let particleGeometry;
      let unifiedInput = null;
      let energyPeak = 0.12;
      let bassPulse = 0;
      let trebleShimmer = 0;
      let beatPulse = 0;
      let lastBeatTime = -10;
      let beatStreak = 0;
      let hintTimeout = null;
      let hasDragged = false;
      let hasPinched = false;
      let hasDoubleTapped = false;

      // UI Elements
      const loadingOverlay = document.getElementById('loadingOverlay');
      const startButton = document.getElementById('startButton');
      const infoButton = document.getElementById('infoButton');
      const settingsButton = document.getElementById('settingsButton');
      const fullscreenButton = document.getElementById('fullscreenButton');
      const infoPanel = document.getElementById('infoPanel');
      const settingsPanel = document.getElementById('settingsPanel');
      const closeInfoButton = document.getElementById('closeInfoButton');
      const closeSettingsButton = document.getElementById('closeSettingsButton');

      infoButton?.setAttribute('aria-expanded', 'false');
      settingsButton?.setAttribute('aria-expanded', 'false');
      const particleCountSlider = document.getElementById('particleCount');
      const particleCountValue = document.getElementById('particleCountValue');
      const shapeDetailSlider = document.getElementById('shapeDetail');
      const shapeDetailValue = document.getElementById('shapeDetailValue');
      const opacitySlider = document.getElementById('opacity');
      const opacityValue = document.getElementById('opacityValue');
      const bloomStrengthSlider = document.getElementById('bloomStrength');
      const bloomStrengthValue = document.getElementById('bloomStrengthValue');
      const particleScaleSlider = document.getElementById('particleScale');
      const particleScaleValue = document.getElementById('particleScaleValue');
      const surpriseButton = document.getElementById('surpriseButton');
      const errorDisplayId = 'error-message';
      const microHint = document.getElementById('microHint');
      const preferDemoAudio =
        new URLSearchParams(window.location.search).get('audio') === 'demo';

      initErrorDisplay(errorDisplayId);

      if (preferDemoAudio && startButton instanceof HTMLButtonElement) {
        startButton.textContent = 'Start Demo Visualizer';
      }

      function showMicroHint(message) {
        if (!(microHint instanceof HTMLElement)) return;
        microHint.textContent = message;
        microHint.classList.add('is-visible');
        if (hintTimeout) {
          window.clearTimeout(hintTimeout);
        }
        hintTimeout = window.setTimeout(() => {
          microHint.classList.remove('is-visible');
        }, 3000);
      }

      // Initialize Visualizer
      function init() {
        // Scene and Camera Setup
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = zoomDistance;

        // Renderer Setup
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        renderer.domElement.classList.add('toy-canvas');

        // Post-Processing Setup
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom Pass for Glow Effect
        bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          bloomStrength, // strength
          0.4, // radius
          0.85 // threshold
        );
        bloomPass.threshold = 0.21;
        bloomPass.strength = bloomStrength;
        bloomPass.radius = 0.55;
        composer.addPass(bloomPass);

        // FXAA Pass for Anti-Aliasing
        fxaaPass = new ShaderPass(FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.set(
          1 / window.innerWidth,
          1 / window.innerHeight
        );
        fxaaPass.renderToScreen = true;
        composer.addPass(fxaaPass);

        // Create Visual Elements
        createShape();
        createParticles();

        // Lighting
        addLighting();

        // Dynamic Background
        createDynamicBackground();

        // Event Listeners
        window.addEventListener('resize', onWindowResize);
        unifiedInput?.dispose();
        unifiedInput = createUnifiedInput({
          target: renderer.domElement,
          boundsElement: renderer.domElement,
          onInput: (state) => {
            if (state.justPressed) {
              const tapLength = state.time - lastTap;
              if (tapLength < 300 && tapLength > 0) {
                changeShape();
                if (!hasDoubleTapped) {
                  hasDoubleTapped = true;
                  showMicroHint('Use ⚙️ for settings and ⛶ for fullscreen.');
                }
              }
              lastTap = state.time;
            }

            const points = state.pointers;
            if (points.length === 1 && state.isPressed) {
              const p = points[0];
              if (!hasDragged) {
                hasDragged = true;
                showMicroHint('Nice! Try pinch to zoom.');
              }
              visualizerShape.rotation.y =
                ((p.normalizedX + 1) / 2) * Math.PI * 2;
              visualizerShape.rotation.x =
                ((1 - p.normalizedY) / 2) * Math.PI;
            } else if (points.length >= 2 && state.isPressed) {
              const [p1, p2] = points;
              if (!hasPinched) {
                hasPinched = true;
                showMicroHint('Pinch zoom feels great. Double tap to swap shapes.');
              }
              const distance = Math.hypot(
                p1.clientX - p2.clientX,
                p1.clientY - p2.clientY
              );
              zoomDistance = THREE.MathUtils.clamp(10 - distance / 50, 2, 15);
              camera.position.z = zoomDistance;
            }
          },
        });

        // UI Event Listeners
        infoButton.addEventListener('click', toggleInfoPanel);
        settingsButton.addEventListener('click', toggleSettingsPanel);
        fullscreenButton.addEventListener('click', toggleFullscreen);
        closeInfoButton?.addEventListener('click', toggleInfoPanel);
        closeSettingsButton?.addEventListener('click', toggleSettingsPanel);
        window.addEventListener('keydown', onKeydown);
      }

      function togglePanel(panel) {
        const isVisible = getComputedStyle(panel).display !== 'none';
        panel.style.display = isVisible ? 'none' : 'block';
      }

      function onKeydown(event) {
        if (event.key !== 'Escape') return;
        infoPanel.style.display = 'none';
        settingsPanel.style.display = 'none';
      }

      // Add Lighting to the Scene
      function addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
      }

      // Create Dynamic Background
      let backgroundUniforms;
      function createDynamicBackground() {
        const bgGeometry = new THREE.PlaneGeometry(2, 2, 1, 1);
        backgroundUniforms = {
          time: { value: 0.0 },
          resolution: {
            value: new THREE.Vector2(window.innerWidth, window.innerHeight),
          },
          color1: { value: new THREE.Color(0x000000) },
          color2: { value: new THREE.Color(0x000000) },
        };
        const bgMaterial = new THREE.ShaderMaterial({
          uniforms: backgroundUniforms,
          vertexShader: `
                    void main() {
                        gl_Position = vec4( position, 1.0 );
                    }
                `,
          fragmentShader: `
                    uniform float time;
                    uniform vec2 resolution;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    void main() {
                        vec2 st = gl_FragCoord.xy / resolution.xy;
                        float pct = 0.5 + 0.5 * sin(time + st.x * 10.0);
                        gl_FragColor = vec4(mix(color1, color2, pct), 1.0);
                    }
                `,
          depthWrite: false,
          side: THREE.DoubleSide,
        });
        const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
        bgMesh.frustumCulled = false;
        scene.add(bgMesh);
      }

      // Create 3D Shape
      function createShape() {
        const geometry = createGeometry();
        const material = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0x222222,
          metalness: 0.5,
          roughness: 0.1,
          wireframe: false,
          transparent: true,
          opacity: shapeOpacity,
          side: THREE.DoubleSide,
        });
        visualizerShape = new THREE.Mesh(geometry, material);
        scene.add(visualizerShape);
      }

      // Create Particle System using Instanced Mesh
      function createParticles() {
        particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        particleMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.7,
        });
        instancedParticles = new THREE.InstancedMesh(
          particleGeometry,
          particleMaterial,
          particleCount
        );
        instancedParticles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        instancedParticles.instanceColor = new THREE.InstancedBufferAttribute(
          new Float32Array(particleCount * 3),
          3
        );
        scene.add(instancedParticles);

        // Initialize Particle Positions and Colors
        const dummy = new THREE.Object3D();
        for (let i = 0; i < particleCount; i++) {
          dummy.position.set(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
          );
          dummy.scale.setScalar(particleScale);
          dummy.updateMatrix();
          instancedParticles.setMatrixAt(i, dummy.matrix);
          // Initialize colors
          instancedParticles.instanceColor.setXYZ(
            i,
            Math.random(),
            Math.random(),
            Math.random()
          );
        }
        instancedParticles.instanceMatrix.needsUpdate = true;
        instancedParticles.instanceColor.needsUpdate = true;
      }

      // Create Geometry Based on Current Shape
      function createGeometry() {
        const detail = shapeDetail;
        switch (shapes[currentShape]) {
          case 'cube':
            return new THREE.BoxGeometry(3, 3, 3, detail, detail, detail);
          case 'torus':
            return new THREE.TorusGeometry(2, 0.7, detail, 100);
          case 'dodecahedron':
            return new THREE.DodecahedronGeometry(2, 0);
          case 'sphere':
          default:
            return new THREE.SphereGeometry(2, detail, detail);
        }
      }

      // Update Visualizer Shape
      function updateShape() {
        if (visualizerShape) {
          scene.remove(visualizerShape);
        }
        createShape();
      }

      // Animation Loop
      function animate(ctx) {
        const delta = clock.getDelta();
        const elapsed = clock.getElapsedTime();

        if (ctx.analyser) {
          analyser = ctx.analyser;
          sampleRate = ctx.analyser.context.sampleRate;
          dataArray = getFrequencyData(ctx.analyser);
          updateVisualizer(elapsed);
        } else {
          analyser = null;
          dataArray = new Uint8Array(0);
        }

        // Update Dynamic Background
        backgroundUniforms.time.value += delta;

        composer.render();
      }

      const clock = new THREE.Clock();

      // Update Visual Elements Based on Audio Data
      function updateVisualizer(elapsed) {
        // Calculate Frequency Bands
        const bass = getFrequencyRange(20, 250);
        const mid = getFrequencyRange(250, 2000);
        const treble = getFrequencyRange(2000, 16000);

        // Calculate Average Frequencies
        const bands = getBandLevels({ analyser, data: dataArray });
        const bassAvg = bands.bass ?? average(bass) / 255;
        const midAvg = bands.mid ?? average(mid) / 255;
        const trebleAvg = bands.treble ?? average(treble) / 255;
        const weightedEnergy = getWeightedEnergy(bands);
        energyPeak = updateEnergyPeak(energyPeak, weightedEnergy);
        const normalized = weightedEnergy / energyPeak;
        bassPulse = Math.max(bassPulse * 0.85, bassAvg);
        trebleShimmer = Math.max(trebleShimmer * 0.8, trebleAvg);
        const beatReady = normalized > 0.88 && elapsed - lastBeatTime > 0.35;
        if (beatReady) {
          lastBeatTime = elapsed;
          beatPulse = 1;
          beatStreak += 1;
          if (beatStreak % 6 === 0) {
            currentShape = (currentShape + 1) % shapes.length;
            updateShape();
            showMicroHint('Shape shift! Double tap to change it yourself.');
          }
        }
        if (elapsed - lastBeatTime > 2.5) {
          beatStreak = 0;
        }

        // Scale Shape Smoothly
        const scale = 1 + bassAvg * 0.55 + normalized * 0.2;
        visualizerShape.scale.lerp(
          new THREE.Vector3(scale, scale, scale),
          0.05
        );

        // Rotate Shape Smoothly
        visualizerShape.rotation.x += 0.002 + midAvg * 0.002 + normalized * 0.001;
        visualizerShape.rotation.y += 0.003 + trebleAvg * 0.002 + normalized * 0.0012;

        // Update Shape Color
        const hue =
          (bassAvg * 0.5 + midAvg * 0.3 + trebleAvg * 0.2 + normalized * 0.1) %
          1;
        visualizerShape.material.color.setHSL(hue, 1, 0.5);
        visualizerShape.material.emissive.setHSL(hue, 1, 0.2);

        // Beat-driven bloom + camera breathing
        beatPulse = Math.max(0, beatPulse * 0.86);
        if (bloomPass) {
          bloomPass.strength =
            bloomStrength + beatPulse * 1.25 + bassPulse * 0.55;
        }
        const zoomPulse =
          Math.sin(elapsed * 1.2) * (0.08 + bassPulse * 0.2) + beatPulse * 0.25;
        camera.position.z = zoomDistance + zoomPulse;

        // Dynamic background glow
        if (backgroundUniforms) {
          const glow = 0.05 + normalized * 0.12 + beatPulse * 0.12;
          const hueShift = (hue + elapsed * 0.02) % 1;
          backgroundUniforms.color1.value.setHSL(hueShift, 0.6, glow);
          backgroundUniforms.color2.value.setHSL(
            (hueShift + 0.18 + trebleShimmer * 0.08) % 1,
            0.7,
            glow * 1.3
          );
        }

        // Update Particles
        const dummy = new THREE.Object3D();
        for (let i = 0; i < particleCount; i++) {
          const freqIndex = Math.floor((i / particleCount) * dataArray.length);
          const audioValue = dataArray[freqIndex] / 255;
          const reactiveValue = Math.min(
            1,
            audioValue * (0.75 + normalized * 0.9 + trebleShimmer * 0.4)
          );

          // Position Update with Smooth Movement
          instancedParticles.getMatrixAt(i, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          dummy.position.y += (reactiveValue - 0.5) * 0.12;
          dummy.rotation.x += 0.012 * reactiveValue;
          dummy.rotation.y += 0.012 * reactiveValue;
          dummy.scale.setScalar(particleScale * (1 + bassPulse * 0.2));
          dummy.updateMatrix();
          instancedParticles.setMatrixAt(i, dummy.matrix);

          // Color Update based on Audio
          const color = new THREE.Color();
          color.setHSL(hue, 1, 0.5 + 0.5 * reactiveValue);
          instancedParticles.instanceColor.setXYZ(i, color.r, color.g, color.b);
        }
        instancedParticles.instanceMatrix.needsUpdate = true;
        instancedParticles.instanceColor.needsUpdate = true;

        bassPulse *= 0.9;
        trebleShimmer *= 0.9;
      }

      // Get Frequencies within a Range
      function getFrequencyRange(low, high) {
        if (!analyser || dataArray.length === 0) return [];
        const nyquist = sampleRate / 2;
        const lowIndex = Math.floor((low / nyquist) * dataArray.length);
        const highIndex = Math.floor((high / nyquist) * dataArray.length);
        return dataArray.slice(lowIndex, highIndex);
      }

      // Calculate Average of an Array
      function average(arr) {
        if (arr.length === 0) return 0;
        const sum = arr.reduce((acc, val) => acc + val, 0);
        return sum / arr.length;
      }

      // Handle Window Resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        backgroundUniforms.resolution.value.set(
          window.innerWidth,
          window.innerHeight
        );

        // Update FXAA Pass Resolution
        fxaaPass.material.uniforms['resolution'].value.set(
          1 / window.innerWidth,
          1 / window.innerHeight
        );
      }

      // Change Shape on Double Tap
      function changeShape() {
        currentShape = (currentShape + 1) % shapes.length;
        updateShape();
      }

      // Toggle Info Panel
      function toggleInfoPanel() {
        togglePanel(infoPanel);
      }

      // Toggle Settings Panel
      function toggleSettingsPanel() {
        togglePanel(settingsPanel);
      }

      // Toggle Fullscreen Mode
      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch((err) => {
            setErrorVisible(
              errorDisplayId,
              `Error attempting to enable fullscreen mode: ${err.message} (${err.name})`
            );
          });
        } else {
          document.exitFullscreen();
        }
      }

      // Update Particle Count
      function updateParticleCount() {
        particleCount = parseInt(particleCountSlider.value);
        particleCountValue.textContent = particleCount;
        // Recreate particles
        scene.remove(instancedParticles);
        createParticles();
      }

      // Update Shape Detail
      function updateShapeDetail() {
        shapeDetail = parseInt(shapeDetailSlider.value);
        shapeDetailValue.textContent = shapeDetail;
        updateShape();
      }

      // Update Shape Opacity
      function updateShapeOpacity() {
        shapeOpacity = parseFloat(opacitySlider.value);
        opacityValue.textContent = shapeOpacity.toFixed(1);
        if (visualizerShape) {
          visualizerShape.material.opacity = shapeOpacity;
        }
      }

      function updateBloomStrength() {
        bloomStrength = parseFloat(bloomStrengthSlider.value);
        bloomStrengthValue.textContent = bloomStrength.toFixed(1);
        if (bloomPass) {
          bloomPass.strength = bloomStrength;
        }
      }

      function updateParticleScale() {
        particleScale = parseFloat(particleScaleSlider.value);
        particleScaleValue.textContent = particleScale.toFixed(1);
      }


      function randomBetween(min, max) {
        return min + Math.random() * (max - min);
      }

      function surpriseMix() {
        particleCountSlider.value = String(Math.round(randomBetween(250, 1800)));
        shapeDetailSlider.value = String(Math.round(randomBetween(8, 64) / 2) * 2);
        opacitySlider.value = randomBetween(0.25, 1).toFixed(1);
        bloomStrengthSlider.value = randomBetween(0.4, 2.5).toFixed(1);
        particleScaleSlider.value = randomBetween(0.5, 2).toFixed(1);

        updateParticleCount();
        updateShapeDetail();
        updateShapeOpacity();
        updateBloomStrength();
        updateParticleScale();
        changeShape();
      }

      // Start Button Click Handler
      startButton.addEventListener('click', async () => {
        startButton.style.display = 'none';
        loadingOverlay.style.display = 'flex';
        init();

        const toy = {
          renderer,
          analyser: null,
          audioCleanup: null,
          dispose() {
            this.audioCleanup?.();
          },
        };
        const { startAudio } = createToyAudioBootstrap(toy);

        try {
          await startAudio(
            animate,
            {
              fftSize: 1024,
              fallbackToSynthetic: true,
              preferSynthetic: preferDemoAudio,
            },
            {
              onError: (err) => {
                console.error('Error accessing microphone:', err);
              },
            }
          );
          setErrorVisible(errorDisplayId);
          loadingOverlay.style.display = 'none';
        } catch (err) {
          setErrorVisible(
            errorDisplayId,
            preferDemoAudio
              ? 'Demo audio could not be loaded. Please try again.'
              : 'Microphone access is required for the visualizer to work.'
          );
          loadingOverlay.style.display = 'none';
          startButton.style.display = 'block';
        }
      });

      // Settings Panel Initialization
      particleCountValue.textContent = particleCount;
      shapeDetailValue.textContent = shapeDetail;
      opacityValue.textContent = shapeOpacity.toFixed(1);
      bloomStrengthValue.textContent = bloomStrength.toFixed(1);
      particleScaleValue.textContent = particleScale.toFixed(1);

      particleCountSlider.addEventListener('input', updateParticleCount);
      shapeDetailSlider.addEventListener('input', updateShapeDetail);
      opacitySlider.addEventListener('input', updateShapeOpacity);
      bloomStrengthSlider.addEventListener('input', updateBloomStrength);
      particleScaleSlider.addEventListener('input', updateParticleScale);
      surpriseButton?.addEventListener('click', surpriseMix);
      window.addEventListener('keydown', (event) => {
        if (event.key.toLowerCase() === 'r') {
          surpriseMix();
        }
      });

      window.addEventListener('pagehide', () => {
        unifiedInput?.dispose();
        window.removeEventListener('keydown', onKeydown);
      });

      // Prevent Context Menu on Long Press
      window.oncontextmenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      };
    </script>
  </body>
</html>
