<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Defrag Sound-Reactive Visualizer</title>
    <link rel="stylesheet" href="../assets/css/base.css" />
    <style>
      :root {
        --defrag-green: #00ff00;
        --defrag-amber: #ffb000;
        --defrag-blue: #00aaff;
        --defrag-red: #ff3366;
        --defrag-purple: #aa55ff;
        --crt-glow: 0 0 10px currentColor, 0 0 20px currentColor;
      }
      
      body {
        background-color: #000000;
        color: var(--defrag-green);
        font-family: 'Courier New', monospace;
        overflow: hidden;
      }
      
      #canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
      }
      
      /* CRT scanline effect */
      .crt-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 100;
        background: 
          repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(0, 0, 0, 0.15) 2px,
            rgba(0, 0, 0, 0.15) 4px
          );
        animation: scanlines 0.1s linear infinite;
      }
      
      @keyframes scanlines {
        0% { background-position: 0 0; }
        100% { background-position: 0 4px; }
      }
      
      .ui-layer {
        position: fixed;
        z-index: 50;
        color: var(--defrag-green);
        text-shadow: var(--crt-glow);
      }
      
      #statusIndicator {
        top: 10px;
        left: 10px;
        font-size: 14px;
        opacity: 0.9;
      }
      
      #defragHeader {
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
      }
      
      #defragHeader h1 {
        font-size: 18px;
        margin: 0;
        letter-spacing: 2px;
        animation: textFlicker 0.15s infinite alternate;
      }
      
      @keyframes textFlicker {
        0% { opacity: 0.95; }
        100% { opacity: 1; }
      }
      
      #statsPanel {
        top: 10px;
        right: 10px;
        font-size: 12px;
        text-align: right;
        line-height: 1.6;
      }
      
      .stats-value {
        color: var(--defrag-amber);
      }
      
      #progressContainer {
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        width: 80%;
        max-width: 600px;
      }
      
      .progress-label {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        margin-bottom: 4px;
      }
      
      .progress-bar {
        height: 20px;
        background: #001a00;
        border: 2px solid var(--defrag-green);
        border-radius: 2px;
        overflow: hidden;
        box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2);
      }
      
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, 
          var(--defrag-green) 0%,
          var(--defrag-amber) 50%,
          var(--defrag-red) 100%
        );
        transition: width 0.3s ease;
        box-shadow: 0 0 15px var(--defrag-green);
      }
      
      #defragLog {
        bottom: 100px;
        left: 10px;
        font-size: 11px;
        max-width: 300px;
        max-height: 150px;
        overflow: hidden;
        opacity: 0.8;
      }
      
      .log-entry {
        animation: logFade 3s forwards;
      }
      
      @keyframes logFade {
        0% { opacity: 1; }
        70% { opacity: 1; }
        100% { opacity: 0.3; }
      }
      
      .log-time {
        color: var(--defrag-amber);
      }
      
      .log-action {
        color: var(--defrag-blue);
      }
      
      #modePanel {
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }
      
      .mode-btn {
        padding: 8px 16px;
        background: transparent;
        border: 1px solid var(--defrag-green);
        color: var(--defrag-green);
        font-family: inherit;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
        text-shadow: var(--crt-glow);
      }
      
      .mode-btn:hover {
        background: rgba(0, 255, 0, 0.1);
        box-shadow: 0 0 10px var(--defrag-green);
      }
      
      .mode-btn.active {
        background: var(--defrag-green);
        color: #000;
        text-shadow: none;
      }
      
      #legendPanel {
        bottom: 10px;
        right: 10px;
        font-size: 11px;
        line-height: 1.5;
      }
      
      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      
      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
      }
    </style>
  </head>
  <body>
    <a href="../index.html" class="home-link">Back to Library</a>
    <canvas id="canvas" class="toy-canvas"></canvas>
    <div class="crt-overlay"></div>
    
    <div id="error-message" style="display: none"></div>
    
    <div id="statusIndicator" class="ui-layer" aria-live="polite"></div>
    
    <div id="defragHeader" class="ui-layer">
      <h1>DISK DEFRAGMENTER</h1>
      <div id="driveInfo">Analyzing Drive C:</div>
    </div>
    
    <div id="statsPanel" class="ui-layer">
      <div>Clusters: <span class="stats-value" id="clusterCount">0</span></div>
      <div>Fragmented: <span class="stats-value" id="fragmented">0%</span></div>
      <div>Optimized: <span class="stats-value" id="optimized">0%</span></div>
      <div>Bass: <span class="stats-value" id="bassLevel">0</span></div>
    </div>
    
    <div id="progressContainer" class="ui-layer">
      <div class="progress-label">
        <span>Progress</span>
        <span id="progressPercent">0%</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>
    </div>
    
    <div id="defragLog" class="ui-layer"></div>
    
    <div id="modePanel" class="ui-layer">
      <button class="mode-btn active" data-mode="defrag">Defrag</button>
      <button class="mode-btn" data-mode="analyze">Analyze</button>
      <button class="mode-btn" data-mode="optimize">Optimize</button>
      <button class="mode-btn" data-mode="rave">Rave Mode</button>
    </div>
    
    <div id="legendPanel" class="ui-layer">
      <div class="legend-item"><span class="legend-color" style="background: #00ff00"></span> Free space</div>
      <div class="legend-item"><span class="legend-color" style="background: #ffb000"></span> Fragmented</div>
      <div class="legend-item"><span class="legend-color" style="background: #0088ff"></span> System files</div>
      <div class="legend-item"><span class="legend-color" style="background: #ff3366"></span> In progress</div>
    </div>

    <script type="module">
      import { setupIframeQualitySync } from '../assets/js/core/iframe-quality-sync.ts';
      import {
        getAverageFrequency,
        getFrequencyData,
        initAudio,
      } from '../assets/js/utils/audio-handler.ts';
      import { showError } from '../assets/js/utils/error-display.ts';
      import { startToyAudio } from '../assets/js/utils/start-audio.ts';

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Block types and their base colors
      const BLOCK_TYPES = {
        FREE: { color: '#001a00', name: 'Free' },
        USED: { color: '#00aa00', name: 'Used' },
        FRAGMENTED: { color: '#ffb000', name: 'Fragmented' },
        SYSTEM: { color: '#0088ff', name: 'System' },
        ACTIVE: { color: '#ff3366', name: 'Active' },
        OPTIMIZED: { color: '#00ff88', name: 'Optimized' },
      };

      // State
      const blocks = [];
      const baseRows = 25;
      const baseCols = 40;
      let rows = baseRows;
      let cols = baseCols;
      let blockWidth = 0;
      let blockHeight = 0;
      let viewWidth = window.innerWidth;
      let viewHeight = window.innerHeight;
      let renderScale = 1;
      let pixelRatio = 1;
      let qualityDensity = 1;
      let currentMode = 'defrag';
      
      // Animation state
      let defragProgress = 0;
      let scanLine = 0;
      let activeBlocks = [];
      let lastMoveTime = 0;
      
      // Audio state
      const DEFAULT_FFT_SIZE = 128;
      const neutralSpectrum = new Uint8Array(DEFAULT_FFT_SIZE / 2);
      let audioDataArray = neutralSpectrum.slice();
      let idleState = true;
      let movingAverageLevel = 0;
      let smoothedBass = 0;
      let smoothedMids = 0;
      let smoothedHighs = 0;
      const idleThreshold = 8;

      // Log system
      const logMessages = [];
      const maxLogMessages = 8;
      
      function addLogMessage(action, detail) {
        const time = new Date().toLocaleTimeString('en-US', { 
          hour12: false, 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit' 
        });
        logMessages.unshift({ time, action, detail });
        if (logMessages.length > maxLogMessages) logMessages.pop();
        updateLogDisplay();
      }
      
      function updateLogDisplay() {
        const logEl = document.getElementById('defragLog');
        logEl.innerHTML = logMessages.map(m => 
          `<div class="log-entry"><span class="log-time">[${m.time}]</span> <span class="log-action">${m.action}</span> ${m.detail}</div>`
        ).join('');
      }

      function resizeCanvas() {
        const effectiveScale = pixelRatio * renderScale;
        viewWidth = window.innerWidth;
        viewHeight = window.innerHeight;
        canvas.width = viewWidth * effectiveScale;
        canvas.height = viewHeight * effectiveScale;
        canvas.style.width = `${viewWidth}px`;
        canvas.style.height = `${viewHeight}px`;
        ctx.setTransform(effectiveScale, 0, 0, effectiveScale, 0, 0);
        blockWidth = viewWidth / cols;
        blockHeight = (viewHeight - 120) / rows; // Leave room for UI
      }

      function getRandomBlockType() {
        const rand = Math.random();
        if (rand < 0.15) return 'FREE';
        if (rand < 0.4) return 'FRAGMENTED';
        if (rand < 0.55) return 'SYSTEM';
        return 'USED';
      }

      function rebuildGrid() {
        blocks.length = 0;
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            blocks.push({
              row: i,
              col: j,
              x: j * blockWidth,
              y: i * blockHeight + 50, // Offset for header
              type: getRandomBlockType(),
              pulsePhase: Math.random() * Math.PI * 2,
              targetX: null,
              targetY: null,
              animating: false,
              highlightIntensity: 0,
              frequencyIndex: Math.floor(Math.random() * (DEFAULT_FFT_SIZE / 2)),
            });
          }
        }
        defragProgress = 0;
        addLogMessage('INIT', `Grid initialized: ${cols}x${rows} clusters`);
        updateStats();
      }

      function updateStats() {
        const total = blocks.length;
        const fragmented = blocks.filter(b => b.type === 'FRAGMENTED').length;
        const optimized = blocks.filter(b => b.type === 'OPTIMIZED').length;
        
        document.getElementById('clusterCount').textContent = total;
        document.getElementById('fragmented').textContent = 
          Math.round(fragmented / total * 100) + '%';
        document.getElementById('optimized').textContent = 
          Math.round(optimized / total * 100) + '%';
        document.getElementById('progressPercent').textContent = 
          Math.round(defragProgress) + '%';
        document.getElementById('progressFill').style.width = 
          defragProgress + '%';
      }

      resizeCanvas();
      rebuildGrid();

      window.addEventListener('resize', () => {
        resizeCanvas();
        rebuildGrid();
      });

      const statusIndicator = document.getElementById('statusIndicator');

      function applyQualityPreset(preset) {
        pixelRatio = Math.min(
          window.devicePixelRatio || 1,
          preset.maxPixelRatio
        );
        renderScale = preset.renderScale ?? 1;
        qualityDensity = Math.max(0.6, preset.particleScale ?? 1);
        rows = Math.max(15, Math.round(baseRows * qualityDensity));
        cols = Math.max(25, Math.round(baseCols * qualityDensity));
        resizeCanvas();
        rebuildGrid();
      }

      setupIframeQualitySync(applyQualityPreset);

      function updateStatusIndicator(state) {
        if (!statusIndicator) return;
        const messages = {
          waiting: '● Waiting for mic…',
          listening: '● Listening…',
          idle: '○ Idle - waiting for sound…',
        };
        statusIndicator.textContent = messages[state] ?? '';
        statusIndicator.style.color = state === 'listening' ? '#00ff00' : '#ffb000';
      }

      updateStatusIndicator('waiting');

      // Mode handling
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentMode = btn.dataset.mode;
          addLogMessage('MODE', `Switched to ${currentMode.toUpperCase()}`);
        });
      });

      class CanvasToy {
        constructor(canvasEl) {
          this.canvas = canvasEl;
          this.analyser = null;
          this.audioCleanup = null;
          this.loopId = null;
          this.renderLoop = null;
          this.renderer = {
            setAnimationLoop: (loop) => {
              if (this.loopId) {
                cancelAnimationFrame(this.loopId);
              }
              this.renderLoop = loop;
              if (!loop) return;
              const tick = () => {
                this.renderLoop?.();
                this.loopId = requestAnimationFrame(tick);
              };
              tick();
            },
          };
        }

        async initAudio(options = {}) {
          const audio = await initAudio(options);
          this.analyser = audio.analyser;
          this.audioCleanup = audio.cleanup;
          return audio;
        }

        dispose() {
          if (this.loopId) {
            cancelAnimationFrame(this.loopId);
          }
          this.renderLoop = null;
          this.loopId = null;
          this.audioCleanup?.();
        }
      }

      const toy = new CanvasToy(canvas);

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      }

      function getBlockColor(block, time, frequencyValue) {
        const baseColor = BLOCK_TYPES[block.type].color;
        const rgb = hexToRgb(baseColor);
        
        // Audio reactivity
        const audioBoost = frequencyValue / 255;
        const pulse = Math.sin(time * 0.003 + block.pulsePhase) * 0.15 + 0.85;
        
        // Mode-specific effects
        let intensity = 1;
        let hueShift = 0;
        
        if (currentMode === 'rave') {
          hueShift = (time * 0.1 + block.row * 10 + block.col * 10) % 360;
          intensity = 0.6 + audioBoost * 0.6;
          // Convert to HSL for hue shifting in rave mode
          return `hsl(${hueShift}, ${70 + audioBoost * 30}%, ${30 + audioBoost * 40}%)`;
        }
        
        if (currentMode === 'analyze') {
          // Scanner effect
          const scanDist = Math.abs(block.row - (scanLine % rows));
          if (scanDist < 2) {
            intensity = 1.5;
          }
        }
        
        if (currentMode === 'optimize') {
          // Ripple effect from audio
          const centerX = cols / 2;
          const centerY = rows / 2;
          const dist = Math.sqrt(
            Math.pow(block.col - centerX, 2) + 
            Math.pow(block.row - centerY, 2)
          );
          const ripple = Math.sin(dist * 0.5 - time * 0.005 + smoothedBass * 5);
          intensity = 0.7 + ripple * 0.3 + audioBoost * 0.3;
        }
        
        // Highlight active blocks
        if (block.highlightIntensity > 0) {
          intensity += block.highlightIntensity * 0.5;
        }
        
        const r = Math.min(255, Math.round(rgb.r * intensity * pulse));
        const g = Math.min(255, Math.round(rgb.g * intensity * pulse));
        const b = Math.min(255, Math.round(rgb.b * intensity * pulse));
        
        return `rgb(${r}, ${g}, ${b})`;
      }

      function performDefragStep(time) {
        // Find fragmented blocks and move them
        const fragmented = blocks.filter(b => b.type === 'FRAGMENTED');
        const free = blocks.filter(b => b.type === 'FREE');
        
        if (fragmented.length === 0 || free.length === 0) {
          if (defragProgress < 100) {
            defragProgress = Math.min(100, defragProgress + 0.5);
          }
          return;
        }
        
        // Beat-based defrag actions
        if (time - lastMoveTime > 200 / (1 + smoothedBass * 2)) {
          lastMoveTime = time;
          
          // Pick a random fragmented block
          const sourceIdx = Math.floor(Math.random() * fragmented.length);
          const source = fragmented[sourceIdx];
          
          // Optimize it
          source.type = 'OPTIMIZED';
          source.highlightIntensity = 1;
          
          addLogMessage('DEFRAG', `Cluster ${source.row * cols + source.col} optimized`);
          defragProgress = Math.min(100, defragProgress + (100 / blocks.length) * 3);
          updateStats();
        }
      }

      function drawBlocks(time) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw dark background with gradient
        const bgGradient = ctx.createLinearGradient(0, 0, 0, viewHeight);
        bgGradient.addColorStop(0, '#000000');
        bgGradient.addColorStop(1, '#001100');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, viewWidth, viewHeight);
        
        blocks.forEach((block, index) => {
          const freqValue = audioDataArray[block.frequencyIndex] || 0;
          const color = getBlockColor(block, time, freqValue);
          
          // Size modulation based on audio
          const audioMod = freqValue / 255;
          const sizeBoost = currentMode === 'rave' ? audioMod * 4 : audioMod * 2;
          const gap = 1;
          
          const w = blockWidth - gap - sizeBoost;
          const h = blockHeight - gap - sizeBoost;
          const x = block.x + sizeBoost / 2;
          const y = block.y + sizeBoost / 2;
          
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);
          
          // Glow effect for active blocks
          if (block.highlightIntensity > 0) {
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10 * block.highlightIntensity;
            ctx.fillRect(x, y, w, h);
            ctx.shadowBlur = 0;
            block.highlightIntensity *= 0.95;
          }
          
          // Border for system files
          if (block.type === 'SYSTEM') {
            ctx.strokeStyle = 'rgba(0, 136, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, w, h);
          }
        });
        
        // Draw scan line in analyze mode
        if (currentMode === 'analyze') {
          const scanY = 50 + (scanLine % rows) * blockHeight;
          ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, scanY);
          ctx.lineTo(viewWidth, scanY);
          ctx.stroke();
          
          // Glow
          ctx.shadowColor = '#00ff00';
          ctx.shadowBlur = 15;
          ctx.stroke();
          ctx.shadowBlur = 0;
          
          scanLine += 0.3 + smoothedBass * 0.5;
        }
      }

      function defragLoop(ctxAudio) {
        const time = performance.now();
        
        if (ctxAudio.analyser) {
          audioDataArray = getFrequencyData(ctxAudio.analyser);
          const averageLevel = getAverageFrequency(audioDataArray);
          movingAverageLevel = movingAverageLevel * 0.7 + averageLevel * 0.3;
          idleState = movingAverageLevel < idleThreshold;
          
          // Frequency band analysis
          const len = audioDataArray.length;
          const bassSlice = Array.from(audioDataArray.slice(0, Math.floor(len * 0.15)));
          const midsSlice = Array.from(audioDataArray.slice(Math.floor(len * 0.15), Math.floor(len * 0.6)));
          const highsSlice = Array.from(audioDataArray.slice(Math.floor(len * 0.6)));
          
          const bass = bassSlice.reduce((a, b) => a + b, 0) / bassSlice.length / 255;
          const mids = midsSlice.reduce((a, b) => a + b, 0) / midsSlice.length / 255;
          const highs = highsSlice.reduce((a, b) => a + b, 0) / highsSlice.length / 255;
          
          smoothedBass = smoothedBass * 0.85 + bass * 0.15;
          smoothedMids = smoothedMids * 0.9 + mids * 0.1;
          smoothedHighs = smoothedHighs * 0.92 + highs * 0.08;
          
          document.getElementById('bassLevel').textContent = 
            Math.round(smoothedBass * 100);
          
          updateStatusIndicator(idleState ? 'idle' : 'listening');
        } else {
          audioDataArray = neutralSpectrum;
          updateStatusIndicator('waiting');
        }
        
        // Mode-specific behavior
        if (currentMode === 'defrag' && !idleState) {
          performDefragStep(time);
        }
        
        drawBlocks(time);
      }

      startToyAudio(toy, defragLoop, {
        fftSize: DEFAULT_FFT_SIZE,
        fallbackToSynthetic: true,
        onCleanup: () => updateStatusIndicator('waiting'),
      }).catch((err) => {
        console.error('Error capturing audio: ', err);
        showError(
          'error-message',
          'Microphone access is required for the visualization to work. Please allow microphone access.'
        );
        updateStatusIndicator('waiting');
        toy.renderer.setAnimationLoop(() =>
          defragLoop({ toy, analyser: null })
        );
      });
      
      // Initial log
      addLogMessage('START', 'Defrag visualizer initialized');
    </script>
  </body>
</html>
