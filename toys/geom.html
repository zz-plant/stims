<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Microphone Input Music Visualizer</title>
    <link rel="stylesheet" href="../assets/css/base.css" />
    <style>
      body {
        background: #000;
      }
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        z-index: 1;
        background: rgba(0, 0, 0, 0.55);
        padding: 12px 14px;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 220px;
      }
      #startButton {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
      }
      .control-group label {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        margin-bottom: 6px;
      }
      .control-group input[type='range'] {
        width: 100%;
      }
      #error-message {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #ff0000;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div data-toy-nav></div>
    <div id="controls">
      <button id="startButton">Start Microphone Visualizer</button>
      <div class="control-group">
        <label for="densityControl">
          <span>Particle Density</span>
          <span id="densityValue">1.0x</span>
        </label>
        <input
          type="range"
          id="densityControl"
          min="0.5"
          max="2"
          step="0.1"
          value="1"
        />
      </div>
      <div class="control-group">
        <label for="speedControl">
          <span>Motion Speed</span>
          <span id="speedValue">1.0x</span>
        </label>
        <input
          type="range"
          id="speedControl"
          min="0.5"
          max="2.5"
          step="0.1"
          value="1"
        />
      </div>
      <div class="control-group">
        <label for="trailControl">
          <span>Trail Blend</span>
          <span id="trailValue">0.25</span>
        </label>
        <input
          type="range"
          id="trailControl"
          min="0.05"
          max="0.6"
          step="0.05"
          value="0.25"
        />
      </div>
    </div>
    <div id="error-message" style="display: none"></div>
    <canvas id="gameCanvas" class="toy-canvas"></canvas>
    <script type="module">
      import { getContextFrequencyData } from '../assets/js/core/animation-loop.ts';
      import { setupIframeQualitySync } from '../assets/js/core/iframe-quality-sync.ts';
      import {
        AudioAccessError,
      } from '../assets/js/utils/audio-handler.ts';
      import {
        getBandLevels,
        getWeightedEnergy,
        updateEnergyPeak,
      } from '../assets/js/utils/audio-reactivity.ts';
      import { setupCanvasResize } from '../assets/js/utils/canvas-resize.ts';
      import {
        clearError,
        showError,
      } from '../assets/js/utils/error-display.ts';
      import { createToyAudioBootstrap } from '../assets/js/utils/toy-audio-bootstrap.ts';
      import { initToyPageShell } from '../assets/js/utils/toy-page-shell.ts';

      initToyPageShell();

      import { startToyAudio } from '../assets/js/utils/start-audio.ts';

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const startButton = document.getElementById('startButton');
      const densityControl = document.getElementById('densityControl');
      const densityValue = document.getElementById('densityValue');
      const speedControl = document.getElementById('speedControl');
      const speedValue = document.getElementById('speedValue');
      const trailControl = document.getElementById('trailControl');
      const trailValue = document.getElementById('trailValue');

      let viewWidth = window.innerWidth;
      let viewHeight = window.innerHeight;
      let resizeCleanup = null;
      let activeQuality = null;
      const baseDensity = 0.6;
      let densityMultiplier = 1;
      let speedMultiplier = 1;
      let trailBlend = 0.25;
      const particles = [];
      const baseParticleCount = 800;
      let particleCount = baseParticleCount;
      let peakLevel = 0.12;
      let bassPulse = 0;
      let trebleGlow = 0;
      let pointerActive = false;
      let pointerX = 0;
      let pointerY = 0;
      let attractStrength = 0.12;

      function applyQualityPreset(preset) {
        activeQuality = preset;
        const effectivePixelRatio =
          Math.min(window.devicePixelRatio || 1, preset.maxPixelRatio) *
          (preset.renderScale ?? 1);

        resizeCleanup?.();
        resizeCleanup = setupCanvasResize(canvas, ctx, {
          maxPixelRatio: effectivePixelRatio,
          onResize: ({ cssWidth, cssHeight }) => {
            viewWidth = cssWidth;
            viewHeight = cssHeight;
          },
        });

        const densityScale = Math.max(baseDensity, preset.particleScale ?? 1);
        particleCount = Math.max(
          200,
          Math.round(baseParticleCount * densityScale * densityMultiplier)
        );
        rebuildParticles();
      }

      setupIframeQualitySync(applyQualityPreset);

      class CanvasToy {
        constructor(canvasEl) {
          this.canvas = canvasEl;
          this.analyser = null;
          this.audioCleanup = null;
          this.loopId = null;
          this.renderLoop = null;
          this.renderer = {
            setAnimationLoop: (loop) => {
              if (this.loopId) {
                cancelAnimationFrame(this.loopId);
              }

              this.renderLoop = loop;
              if (!loop) return;

              const tick = () => {
                this.renderLoop?.();
                this.loopId = requestAnimationFrame(tick);
              };

              tick();
            },
          };
        }

        dispose() {
          if (this.loopId) {
            cancelAnimationFrame(this.loopId);
          }

          this.renderLoop = null;
          this.loopId = null;
          this.audioCleanup?.();
        }
      }

      const toy = new CanvasToy(canvas);
      const { startAudio } = createToyAudioBootstrap(toy);

      function createParticle() {
        const depth = Math.random();
        const size = Math.random() * 3 + 1;
        return {
          x: Math.random() * viewWidth,
          y: Math.random() * viewHeight,
          depth,
          size,
          baseSize: size,
          baseAlpha: 0.3 + depth * 0.4,
          velocityX: (Math.random() - 0.5) * 2 * (0.4 + depth),
          velocityY: (Math.random() - 0.5) * 2 * (0.4 + depth),
          hue: Math.random() * 360,
          lightness: 50,
          alpha: 0.5,
          rotation: Math.random() * 360,
          angularVelocity: (Math.random() - 0.5) * 2,
        };
      }

      function rebuildParticles() {
        particles.length = 0;
        for (let i = 0; i < particleCount; i++) {
          particles.push(createParticle());
        }
      }

      function animate(ctxAudio) {
        const frequencyData = getContextFrequencyData(ctxAudio);

        if (ctxAudio.analyser) {
          const bands = getBandLevels({
            analyser: ctxAudio.analyser,
            data: frequencyData,
          });
          const weightedEnergy = getWeightedEnergy(bands, { boost: 1.4 });
          peakLevel = updateEnergyPeak(peakLevel, weightedEnergy);
          const normalized = peakLevel ? weightedEnergy / peakLevel : 0;
          bassPulse = Math.max(bassPulse * 0.85, bands.bass);
          trebleGlow = Math.max(trebleGlow * 0.8, bands.treble);
          const hue = ((bassPulse * 0.7 + normalized * 0.3) * 360) % 360;
          const innerLightness = 25 + bassPulse * 30 + trebleGlow * 12;
          const outerLightness = 8 + normalized * 12;
          const gradient = ctx.createRadialGradient(
            viewWidth / 2,
            viewHeight / 2,
            0,
            viewWidth / 2,
            viewHeight / 2,
            viewWidth
          );
          gradient.addColorStop(0, `hsl(${hue}, 100%, ${innerLightness}%)`);
          gradient.addColorStop(
            1,
            `hsl(${(hue + 60) % 360}, 100%, ${outerLightness}%)`
          );
          ctx.fillStyle = gradient;
        } else {
          ctx.fillStyle = '#000';
        }
        ctx.globalAlpha = trailBlend;
        ctx.fillRect(0, 0, viewWidth, viewHeight);
        ctx.globalAlpha = 1;

        particles.forEach((p, index) => {
          const depthFactor = 0.6 + p.depth * 0.9;
          p.x += p.velocityX * speedMultiplier * depthFactor;
          p.y += p.velocityY * speedMultiplier * depthFactor;
          p.rotation += p.angularVelocity;

          if (pointerActive) {
            const dx = pointerX - p.x;
            const dy = pointerY - p.y;
            p.x += dx * attractStrength * (0.35 + p.depth * 0.65);
            p.y += dy * attractStrength * (0.35 + p.depth * 0.65);
          }

          if (p.x < -p.size) p.x = viewWidth + p.size;
          if (p.x > viewWidth + p.size) p.x = -p.size;
          if (p.y < -p.size) p.y = viewHeight + p.size;
          if (p.y > viewHeight + p.size) p.y = -p.size;

          if (ctxAudio.analyser && frequencyData.length) {
            const freqIndex = Math.floor(index % frequencyData.length);
            const amplitude = frequencyData[freqIndex] / 255;
            const energyBoost = 0.7 + peakLevel * 1.1 + bassPulse * 0.8;
            p.size =
              p.baseSize * (0.8 + p.depth) + amplitude * 12 * energyBoost;
            p.hue = (p.hue + amplitude * (6 + trebleGlow * 10)) % 360;
            p.lightness = 30 + amplitude * 25 + trebleGlow * 15 + p.depth * 10;
            p.alpha = Math.min(
              1,
              (p.baseAlpha + amplitude * 0.55 + peakLevel * 0.2) *
                (0.7 + p.depth * 0.6)
            );
          }

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate((p.rotation * Math.PI) / 180);
          ctx.fillStyle = `hsla(${p.hue}, 100%, ${p.lightness}%, ${p.alpha})`;
          ctx.beginPath();
          ctx.moveTo(0, -p.size / 2);
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(
              (p.size / 2) * Math.cos(((18 + i * 72) * Math.PI) / 180),
              (p.size / 2) * Math.sin(((18 + i * 72) * Math.PI) / 180)
            );
            ctx.lineTo(
              (p.size / 4) * Math.cos(((54 + i * 72) * Math.PI) / 180),
              (p.size / 4) * Math.sin(((54 + i * 72) * Math.PI) / 180)
            );
          }
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        });

        if (ctxAudio.analyser && frequencyData.length) {
          const barWidth = (viewWidth / frequencyData.length) * 2.5;
          let x = 0;
          for (let i = 0; i < frequencyData.length; i++) {
            const barHeight = frequencyData[i] * (1.1 + peakLevel * 0.6);
            const hue = (i / frequencyData.length) * 360;
            ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.7)`;
            ctx.fillRect(x, viewHeight - barHeight, barWidth, barHeight);
            x += barWidth + 1;
          }
        }

        if (ctxAudio.analyser) {
          const timeData = new Uint8Array(ctxAudio.analyser.fftSize);
          ctxAudio.analyser.getByteTimeDomainData(timeData);
          ctx.lineWidth = 2;
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 + peakLevel * 0.6})`;
          ctx.beginPath();
          const sliceWidth = viewWidth / timeData.length;
          let x = 0;
          for (let i = 0; i < timeData.length; i++) {
            const v = timeData[i] / 128.0;
            const y = (v * viewHeight) / 2;
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
            x += sliceWidth;
          }
          ctx.lineTo(viewWidth, viewHeight / 2);
          ctx.stroke();
        }

        bassPulse *= 0.9;
        trebleGlow *= 0.9;
      }

      startButton.addEventListener('click', async () => {
        startButton.disabled = true;
        startButton.textContent = 'Connectingâ€¦';
        clearError('error-message');

        try {
          await startAudio(
            animate,
            {
              fftSize: 1024,
              fallbackToSynthetic: true,
            },
            {
              onSuccess: () => {
                startButton.textContent = 'Visualizer running';
              },
              onError: (error) => {
                console.error('Error starting audio:', error);
              },
            }
          );
        } catch (error) {
          startButton.disabled = false;
          startButton.textContent = 'Retry Microphone Visualizer';

          if (error instanceof AudioAccessError) {
            showError('error-message', error.message);
          } else {
            showError(
              'error-message',
              'Error accessing microphone. Please check your settings and try again.'
            );
          }
        }
      });

      function updateDensity() {
        densityMultiplier = Number(densityControl.value);
        densityValue.textContent = `${densityMultiplier.toFixed(1)}x`;
        applyQualityPreset(
          activeQuality ?? { maxPixelRatio: 2, renderScale: 1 }
        );
      }

      function updateSpeed() {
        speedMultiplier = Number(speedControl.value);
        speedValue.textContent = `${speedMultiplier.toFixed(1)}x`;
      }

      function updateTrail() {
        trailBlend = Number(trailControl.value);
        trailValue.textContent = trailBlend.toFixed(2);
      }

      function updatePointerFromEvent(event) {
        const rect = canvas.getBoundingClientRect();
        pointerX = event.clientX - rect.left;
        pointerY = event.clientY - rect.top;
      }

      densityControl.addEventListener('input', updateDensity);
      speedControl.addEventListener('input', updateSpeed);
      trailControl.addEventListener('input', updateTrail);

      canvas.addEventListener('pointerdown', (event) => {
        pointerActive = true;
        updatePointerFromEvent(event);
      });
      canvas.addEventListener('pointermove', (event) => {
        if (!pointerActive) return;
        updatePointerFromEvent(event);
      });
      window.addEventListener('pointerup', () => {
        pointerActive = false;
      });

      updateDensity();
      updateSpeed();
      updateTrail();

      window.addEventListener('beforeunload', () => {
        toy.dispose?.();
      });
    </script>
  </body>
</html>
