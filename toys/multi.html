<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Multi-Capability Visualizer (WebGPU/WebGL Fallback)</title>
    <link rel="stylesheet" href="../assets/css/base.css" />
    <style>
      body,
      html {
        height: 100%;
        background-color: #000000;
      }

      .capability-banner {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 196, 105, 0.12);
        color: #ffe5bd;
        border: 1px solid rgba(255, 196, 105, 0.5);
        padding: 10px 14px;
        border-radius: 10px;
        font-size: 0.95rem;
        letter-spacing: 0.01em;
        backdrop-filter: blur(8px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        display: none;
        z-index: 5;
      }
    </style>
  </head>
  <body>
    <div data-toy-nav></div>
    <canvas id="webglCanvas" class="toy-canvas"></canvas>
    <div
      id="capability-banner"
      class="capability-banner"
      aria-live="polite"
    ></div>
    <div id="error-message" style="display: none"></div>
    <script type="module">
      import { initToyPageShell } from '../assets/js/utils/toy-page-shell.ts';
      import * as THREE from 'three';
      import { getContextFrequencyData } from '../assets/js/core/animation-loop.ts';
      import WebToy from '../assets/js/core/web-toy.ts';
      import { getWeightedAverageFrequency } from '../assets/js/utils/audio-handler.ts';
      import { showError } from '../assets/js/utils/error-display.ts';
      import createPeakDetector from '../assets/js/utils/peak-detector.ts';
      import { startToyAudio } from '../assets/js/utils/start-audio.ts';
      import { createMultiFunAdapter } from '../assets/multi/fun-adapter.ts';
      import { initFunControls } from '../assets/ui/fun-controls.ts';
      import { initHints } from '../assets/ui/hints.ts';
      import {
        requestMotionPermission,
        requiresMotionPermission,
        supportsDeviceOrientation,
      } from '../assets/js/utils/motion-permission.ts';

      const toyNav = initToyPageShell();

      const canvas = document.getElementById('webglCanvas');
      const capabilityBanner = document.getElementById('capability-banner');
      const allowWebGLFallback = true;
      const hasWebGPU = Boolean(navigator.gpu);
      const useWebGLFallback = allowWebGLFallback && !hasWebGPU;

      if (useWebGLFallback && capabilityBanner) {
        capabilityBanner.textContent =
          'WebGPU is unavailable, so you are seeing the lighter WebGL preset with fewer particles and simpler lighting.';
        capabilityBanner.style.display = 'block';
      } else if (!hasWebGPU && capabilityBanner) {
        capabilityBanner.textContent =
          'WebGPU is unavailable in this browser. Try a WebGPU-enabled browser for the full visual fidelity.';
        capabilityBanner.style.display = 'block';
      }

      const hintsButtonHost =
        toyNav?.querySelector('.active-toy-nav__actions') ?? null;

      initHints({
        id: 'multi-visualizer',
        tips: [
          'Play music or tap to trigger sparkles.',
          'Switch to Party Mode for bigger motion.',
          'Tilt or move your device to shove the shapes around.',
        ],
        trigger: 'idle',
        manualButton: {
          container: hintsButtonHost,
          label: 'Need tips?',
        },
      });

      const toy = new WebToy({
        canvas,
        cameraOptions: {
          fov: 75,
          position: { x: 0, y: 0, z: 50 },
        },
        rendererOptions: !useWebGLFallback
          ? {
              antialias: true,
              exposure: 1,
              maxPixelRatio: 2,
            }
          : {
              antialias: false,
              exposure: 0.85,
              maxPixelRatio: 1.1,
            },
        ambientLightOptions: {
          color: 0xffffff,
          intensity: useWebGLFallback ? 0.7 : 1,
        },
      });

      const baseMaterial = useWebGLFallback
        ? THREE.MeshLambertMaterial
        : THREE.MeshStandardMaterial;

      const torusKnot = new THREE.Mesh(
        new THREE.TorusKnotGeometry(12, 4, 120, 16),
        new baseMaterial({
          color: 0x00f5ff,
          ...(useWebGLFallback
            ? {}
            : {
                emissive: 0x003344,
                emissiveIntensity: 0.7,
                metalness: 0.5,
                roughness: 0.2,
              }),
        })
      );
      toy.scene.add(torusKnot);

      const pointLight = new THREE.PointLight(
        0xff0000,
        useWebGLFallback ? 1.25 : 2,
        useWebGLFallback ? 80 : 100
      );
      pointLight.position.set(10, 20, 20);
      toy.scene.add(pointLight);

      const keyLight = new THREE.PointLight(
        0x00f5ff,
        useWebGLFallback ? 0.8 : 1.3,
        140
      );
      keyLight.position.set(0, 0, 35);
      toy.scene.add(keyLight);

      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = useWebGLFallback ? 320 : 1200;
      const particlesPosition = new Float32Array(particlesCount * 3);
      for (let i = 0; i < particlesCount * 3; i++) {
        particlesPosition[i] = (Math.random() - 0.5) * 500;
      }
      particlesGeometry.setAttribute(
        'position',
        new THREE.BufferAttribute(particlesPosition, 3)
      );
      const particlesMaterial = new THREE.PointsMaterial({
        color: 0x00ff99,
        size: useWebGLFallback ? 0.6 : 0.5,
        transparent: true,
        opacity: useWebGLFallback ? 0.45 : 0.35,
      });
      const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      toy.scene.add(particles);

      const hazeColor = 0x050505;
      let hazeDensity = useWebGLFallback ? 0.0025 : 0.0018;
      toy.scene.fog = new THREE.FogExp2(hazeColor, hazeDensity);

      const shapes = [];
      function createRandomShape() {
        const shapeType = Math.floor(Math.random() * 3);
        let shape;
        const shapeMaterial = new baseMaterial({
          color: Math.random() * 0xffffff,
          transparent: true,
          opacity: useWebGLFallback ? 0.6 : 0.7,
          ...(useWebGLFallback
            ? {}
            : {
                emissive: Math.random() * 0x222222,
                metalness: 0.7,
                roughness: 0.4,
              }),
        });

        switch (shapeType) {
          case 0:
            shape = new THREE.SphereGeometry(5, 32, 32);
            break;
          case 1:
            shape = new THREE.BoxGeometry(7, 7, 7);
            break;
          default:
            shape = new THREE.ConeGeometry(5, 15, 32);
            break;
        }

        const mesh = new THREE.Mesh(shape, shapeMaterial);
        mesh.position.set(
          Math.random() * 100 - 50,
          Math.random() * 100 - 50,
          Math.random() * -500
        );
        toy.scene.add(mesh);
        shapes.push(mesh);
      }

      for (let i = 0; i < (useWebGLFallback ? 3 : 5); i++) {
        createRandomShape();
      }

      const adapter = createMultiFunAdapter({
        torusMaterial: torusKnot.material,
        pointLight,
        particlesMaterial,
        shapes,
      });

      const funControls = initFunControls({
        paletteOptions: adapter.paletteOptions,
        onPaletteChange: (palette, colors) =>
          adapter.setPalette(palette, colors),
        onMotionChange: (intensity, mode) => adapter.setMotion(intensity, mode),
        onAudioToggle: (enabled) => adapter.setAudioReactive(enabled),
      });

      const extras = document.createElement('div');
      extras.innerHTML = `
        <label class="fun-toggle">
          <input type="checkbox" class="fun-sparkles" checked aria-label="Enable sparkles" />
          Sparkles
        </label>
        <label class="fun-toggle">
          <input type="checkbox" class="fun-bursts" checked aria-label="Enable bursts" />
          Bursts
        </label>
        <label>
          Peak sensitivity
          <input class="fun-slider fun-sensitivity" type="range" min="0.05" max="1" step="0.05" value="0.2" aria-label="Peak sensitivity" />
        </label>
        <label>
          Particle size <span class="fun-particle-size-value">0.6</span>
          <input class="fun-slider fun-particle-size" type="range" min="0.3" max="1.2" step="0.05" value="${
            useWebGLFallback ? 0.6 : 0.5
          }" aria-label="Particle size" />
        </label>
        <label>
          Haze density <span class="fun-haze-value">0.002</span>
          <input class="fun-slider fun-haze" type="range" min="0" max="0.01" step="0.0005" value="${hazeDensity}" aria-label="Haze density" />
        </label>
      `;

      funControls.container.appendChild(extras);

      let motionEnabled = false;
      const handleDeviceOrientation = (event) => {
        toy.camera.rotation.x = (event.beta / 180) * Math.PI;
        toy.camera.rotation.y = (event.gamma / 90) * Math.PI;
      };

      const enableMotion = async () => {
        if (motionEnabled) return;
        const permission = await requestMotionPermission();
        if (permission !== 'granted') return;
        motionEnabled = true;
        window.addEventListener('deviceorientation', handleDeviceOrientation);
      };

      if (supportsDeviceOrientation()) {
        if (requiresMotionPermission()) {
          const requestOnFirstInteraction = () => {
            void enableMotion();
          };
          window.addEventListener('pointerdown', requestOnFirstInteraction, {
            once: true,
          });
          window.addEventListener('touchstart', requestOnFirstInteraction, {
            once: true,
          });
        } else {
          void enableMotion();
        }
      }

      const clock = new THREE.Clock();
      const sparkleGroup = new THREE.Group();
      toy.scene.add(sparkleGroup);

      const sparklePool = Array.from({ length: 80 }, () => {
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          'position',
          new THREE.Float32BufferAttribute([0, 0, 0], 3)
        );
        const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 1,
          transparent: true,
          opacity: 0,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });
        const points = new THREE.Points(geometry, material);
        points.visible = false;
        sparkleGroup.add(points);
        return {
          points,
          velocity: new THREE.Vector3(),
          life: 0,
          maxLife: 1,
          sizeBase: 1,
        };
      });

      let sparkleIndex = 0;
      let sparklesEnabled = true;

      function activateSparkle(origin) {
        const sparkle = sparklePool[sparkleIndex];
        sparkleIndex = (sparkleIndex + 1) % sparklePool.length;
        const hue = Math.random();
        const scale = 0.6 + Math.random() * 1.4;

        sparkle.points.position
          .copy(origin)
          .add(
            new THREE.Vector3(
              (Math.random() - 0.5) * 12,
              (Math.random() - 0.5) * 12,
              (Math.random() - 0.5) * 20
            )
          );
        sparkle.velocity.set(
          (Math.random() - 0.5) * 0.8,
          (Math.random() - 0.5) * 0.8,
          (Math.random() - 0.3) * 1.2
        );
        sparkle.life = sparkle.maxLife = 0.4 + Math.random() * 0.9;
        sparkle.sizeBase = scale;
        sparkle.points.visible = true;
        const sparkleMaterial = sparkle.points.material;
        if (sparkleMaterial instanceof THREE.PointsMaterial) {
          sparkleMaterial.color.setHSL(hue, 0.8, 0.6);
        }
      }

      function triggerSparkles(count = 12) {
        if (!sparklesEnabled) return;
        for (let i = 0; i < count; i++) {
          activateSparkle(torusKnot.position);
        }
      }

      function updateSparkles(delta) {
        sparklePool.forEach((sparkle) => {
          if (sparkle.life <= 0) return;
          sparkle.life -= delta;
          const t = Math.max(sparkle.life / sparkle.maxLife, 0);
          const material = sparkle.points.material;
          if (material instanceof THREE.PointsMaterial) {
            material.opacity = t;
            material.size = sparkle.sizeBase * (0.75 + t * 0.75);
          }
          sparkle.points.position.addScaledVector(sparkle.velocity, delta * 60);
          sparkle.velocity.multiplyScalar(0.98);
          if (sparkle.life <= 0) {
            sparkle.points.visible = false;
          }
        });
      }

      let burstsEnabled = true;
      let burstValue = 0;
      let burstTarget = 0;
      let lastFrequencyData = new Uint8Array(0);
      let peakSensitivity = 0.2;

      const handlePeak = (level, threshold) => {
        const strength = Math.min(1.25, (level - threshold) * 3);
        burstTarget = Math.max(burstTarget, strength);
        triggerSparkles(Math.max(8, Math.floor(strength * 16)));
      };

      const handleRelease = () => {
        burstTarget = 0;
      };

      let peakDetector = createPeakDetector({
        getData: () => lastFrequencyData,
        sensitivity: peakSensitivity,
        onPeak: handlePeak,
        onRelease: handleRelease,
      });

      const sensitivitySlider =
        funControls.container.querySelector('.fun-sensitivity');
      sensitivitySlider?.addEventListener('input', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        const nextValue = Number(target.value);
        peakSensitivity = nextValue;
        peakDetector = createPeakDetector({
          getData: () => lastFrequencyData,
          sensitivity: peakSensitivity,
          onPeak: handlePeak,
          onRelease: handleRelease,
        });
      });

      const sparklesToggle =
        funControls.container.querySelector('.fun-sparkles');
      sparklesToggle?.addEventListener('change', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        sparklesEnabled = target.checked;
      });

      const burstsToggle = funControls.container.querySelector('.fun-bursts');
      burstsToggle?.addEventListener('change', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        burstsEnabled = target.checked;
      });

      const particleSizeSlider =
        funControls.container.querySelector('.fun-particle-size');
      const particleSizeValue = funControls.container.querySelector(
        '.fun-particle-size-value'
      );
      particleSizeSlider?.addEventListener('input', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        const nextValue = Number(target.value);
        particlesMaterial.size = nextValue;
        if (particleSizeValue) {
          particleSizeValue.textContent = nextValue.toFixed(2);
        }
      });
      if (particleSizeValue) {
        particleSizeValue.textContent = particlesMaterial.size.toFixed(2);
      }

      const hazeSlider = funControls.container.querySelector('.fun-haze');
      const hazeValue = funControls.container.querySelector('.fun-haze-value');
      hazeSlider?.addEventListener('input', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        hazeDensity = Number(target.value);
        if (toy.scene.fog instanceof THREE.FogExp2) {
          toy.scene.fog.density = hazeDensity;
        } else {
          toy.scene.fog = new THREE.FogExp2(hazeColor, hazeDensity);
        }
        if (hazeValue) {
          hazeValue.textContent = hazeDensity.toFixed(4);
        }
      });
      if (hazeValue) {
        hazeValue.textContent = hazeDensity.toFixed(4);
      }

      function animate(ctx) {
        const delta = clock.getDelta();
        lastFrequencyData = getContextFrequencyData(ctx);
        const avgFrequency = getWeightedAverageFrequency(lastFrequencyData);

        peakDetector.update(lastFrequencyData);
        const spin = adapter.computeMotion(avgFrequency);

        burstValue = THREE.MathUtils.damp(
          burstValue,
          burstsEnabled ? burstTarget : 0,
          5,
          delta
        );
        burstTarget = THREE.MathUtils.damp(burstTarget, 0, 1.5, delta);

        const burstScale = 1 + burstValue * 0.65;
        torusKnot.rotation.x += spin + burstValue * 0.02;
        torusKnot.rotation.y += spin + burstValue * 0.02;
        torusKnot.scale.setScalar(burstScale);

        pointLight.intensity =
          Math.max(useWebGLFallback ? 0.4 : 0.6, avgFrequency / 140) *
          (spin * 500 + 0.5 + burstValue * 2) *
          (useWebGLFallback ? 0.6 : 1);

        particles.rotation.y += 0.001 + spin / 10;

        shapes.forEach((shape) => {
          shape.rotation.x += 0.01 + spin * 2 + burstValue * 0.03;
          shape.rotation.y += 0.01 + spin * 1.5 + burstValue * 0.02;
          shape.position.z += 0.5 + spin * 60 + burstValue * 4;
          shape.scale.setScalar(1 + burstValue * 0.5);

          if (shape.position.z > 10) {
            shape.position.z = -500;
          }
        });

        updateSparkles(delta);

        ctx.toy.render();
      }

      startToyAudio(toy, animate).catch((err) => {
        console.error('The following error occurred: ' + err);
        funControls.setAudioAvailable(false);
        showError(
          'error-message',
          'Microphone access is unavailable. Visuals will run without audio reactivity.'
        );
        const silentContext = { toy, analyser: null };
        toy.renderer.setAnimationLoop(() => animate(silentContext));
      });
    </script>
  </body>
</html>
