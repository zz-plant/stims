<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>SVG + Three.js Hybrid Visualizer</title>
    <link rel="stylesheet" href="../assets/css/base.css" />
    <style>
      :root {
        --primary-glow: #ff66aa;
        --secondary-glow: #00ffcc;
        --tertiary-glow: #6644ff;
      }
      
      body {
        background: #0a0a12;
        overflow: hidden;
      }
      
      #overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        filter: url('#displacementFilter');
        mix-blend-mode: screen;
      }
      
      .svg-layer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
      }
      
      /* Animated strokes */
      .stroke-animate {
        stroke-dasharray: 1000;
        stroke-dashoffset: 1000;
        animation: dash 8s linear infinite alternate;
      }
      
      @keyframes dash {
        to { stroke-dashoffset: 0; }
      }
      
      @keyframes pulse {
        0%, 100% { transform: scale(1); opacity: 0.8; }
        50% { transform: scale(1.1); opacity: 1; }
      }
      
      @keyframes rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      
      @keyframes colorCycle {
        0% { stop-color: #ff66aa; }
        33% { stop-color: #00ffcc; }
        66% { stop-color: #6644ff; }
        100% { stop-color: #ff66aa; }
      }
      
      .rotating-slow {
        transform-origin: center;
        animation: rotate 30s linear infinite;
      }
      
      .rotating-fast {
        transform-origin: center;
        animation: rotate 15s linear infinite reverse;
      }
      
      #error-message {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #ff0000;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      
      #controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        display: flex;
        gap: 12px;
        background: rgba(10, 10, 18, 0.8);
        padding: 12px 20px;
        border-radius: 30px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .control-btn {
        padding: 8px 16px;
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: #fff;
        border-radius: 20px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.3s ease;
      }
      
      .control-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: var(--primary-glow);
        box-shadow: 0 0 15px rgba(255, 102, 170, 0.3);
      }
      
      .control-btn.active {
        background: linear-gradient(135deg, var(--primary-glow), var(--secondary-glow));
        border-color: transparent;
        color: #000;
      }
      
      #stats {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100;
        color: rgba(255, 255, 255, 0.7);
        font-size: 12px;
        font-family: monospace;
        text-align: right;
      }
    </style>
  </head>
  <body>
    <a href="../index.html" class="home-link">Back to Library</a>
    <div id="error-message" style="display: none"></div>
    
    <!-- SVG Filters -->
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="0" height="0">
      <defs>
        <filter id="displacementFilter">
          <feTurbulence
            id="turbulence"
            type="fractalNoise"
            baseFrequency="0.015"
            numOctaves="4"
            result="turbulence"
          />
          <feDisplacementMap
            id="displacementMap"
            in="SourceGraphic"
            in2="turbulence"
            scale="80"
            xChannelSelector="R"
            yChannelSelector="G"
          />
        </filter>
        
        <filter id="glow">
          <feGaussianBlur stdDeviation="4" result="blur" />
          <feMerge>
            <feMergeNode in="blur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
        
        <radialGradient id="centerGlow" cx="50%" cy="50%" r="50%">
          <stop id="glowStop1" offset="0%" style="stop-color: #ffffff; stop-opacity: 1" />
          <stop id="glowStop2" offset="50%" style="stop-color: #ff66aa; stop-opacity: 0.6" />
          <stop offset="100%" style="stop-color: transparent; stop-opacity: 0" />
        </radialGradient>
        
        <linearGradient id="ringGradient" gradientTransform="rotate(90)">
          <stop id="ringStop1" offset="0%" style="stop-color: #00ffcc" />
          <stop id="ringStop2" offset="50%" style="stop-color: #6644ff" />
          <stop id="ringStop3" offset="100%" style="stop-color: #ff66aa" />
        </linearGradient>
      </defs>
    </svg>
    
    <!-- Main SVG Overlay -->
    <div id="overlay">
      <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
        <!-- Central glowing orb -->
        <circle
          id="mainOrb"
          cx="50%"
          cy="50%"
          r="120"
          fill="url(#centerGlow)"
          style="filter: url(#glow); opacity: 0.9;"
        />
        
        <!-- Inner pulsing ring -->
        <circle
          id="innerRing"
          cx="50%"
          cy="50%"
          r="80"
          fill="none"
          stroke="url(#ringGradient)"
          stroke-width="3"
          style="filter: url(#glow); opacity: 0.8;"
          class="rotating-fast"
        />
        
        <!-- Outer rings -->
        <g id="outerRings" class="rotating-slow">
          <circle cx="50%" cy="50%" r="200" fill="none" stroke="#ff66aa" stroke-width="1" opacity="0.4" />
          <circle cx="50%" cy="50%" r="240" fill="none" stroke="#00ffcc" stroke-width="1" opacity="0.3" />
          <circle cx="50%" cy="50%" r="280" fill="none" stroke="#6644ff" stroke-width="1" opacity="0.2" />
        </g>
        
        <!-- Animated waveform paths -->
        <g id="waveformGroup" transform="translate(0, 0)">
          <path id="waveform1" d="" fill="none" stroke="#ff66aa" stroke-width="2" opacity="0.6" />
          <path id="waveform2" d="" fill="none" stroke="#00ffcc" stroke-width="2" opacity="0.5" />
          <path id="waveform3" d="" fill="none" stroke="#6644ff" stroke-width="2" opacity="0.4" />
        </g>
        
        <!-- Frequency bars (circular) -->
        <g id="freqBars" transform="translate(50%, 50%)"></g>
        
        <!-- Particle sparks -->
        <g id="sparks"></g>
      </svg>
    </div>
    
    <!-- Secondary SVG layer for geometric patterns -->
    <svg class="svg-layer" xmlns="http://www.w3.org/2000/svg" id="geoLayer">
      <g id="hexGrid"></g>
      <g id="triangles" class="rotating-slow"></g>
    </svg>
    
    <div id="controls">
      <button class="control-btn active" data-mode="hybrid">Hybrid</button>
      <button class="control-btn" data-mode="spheres">Spheres</button>
      <button class="control-btn" data-mode="waveform">Waveform</button>
      <button class="control-btn" data-mode="geometric">Geometric</button>
    </div>
    
    <div id="stats">
      <div>FPS: <span id="fpsCounter">0</span></div>
      <div>Bass: <span id="bassLevel">0</span></div>
      <div>Mode: <span id="currentMode">Hybrid</span></div>
    </div>

    <script type="module">
      import * as THREE from 'three';
      import {
        getFrequencyData,
        initAudio,
      } from '../assets/js/utils/audio-handler.ts';
      import { startToyAudio } from '../assets/js/utils/start-audio.ts';
      import { ensureWebGL } from '../assets/js/utils/webgl-check.ts';

      const errorEl = document.getElementById('error-message');
      let currentMode = 'hybrid';
      let lastFrameTime = performance.now();
      let frameCount = 0;

      function displayError(message) {
        if (errorEl) {
          errorEl.textContent = message;
          errorEl.style.display = 'block';
        }
      }

      function hideError() {
        if (errorEl) {
          errorEl.style.display = 'none';
        }
      }

      if (!ensureWebGL()) {
        displayError('WebGL is not supported in your browser.');
      }

      // Three.js setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.insertBefore(renderer.domElement, document.body.firstChild);

      // Main sphere cluster
      const sphereGroup = new THREE.Group();
      const spheres = [];
      
      // Central glowing sphere
      const mainGeometry = new THREE.IcosahedronGeometry(4, 3);
      const mainMaterial = new THREE.MeshStandardMaterial({
        color: 0xff66aa,
        roughness: 0.2,
        metalness: 0.8,
        emissive: 0xff2255,
        emissiveIntensity: 0.4,
      });
      const mainSphere = new THREE.Mesh(mainGeometry, mainMaterial);
      sphereGroup.add(mainSphere);
      spheres.push({ mesh: mainSphere, baseScale: 1.0, type: 'main' });

      // Orbiting spheres with trails
      const orbitCount = 8;
      for (let i = 0; i < orbitCount; i++) {
        const orbitGeometry = new THREE.SphereGeometry(0.8, 24, 24);
        const hue = i / orbitCount;
        const orbitMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(hue, 0.9, 0.6),
          roughness: 0.3,
          metalness: 0.7,
          emissive: new THREE.Color().setHSL(hue, 0.9, 0.3),
          emissiveIntensity: 0.3,
        });
        const orbitSphere = new THREE.Mesh(orbitGeometry, orbitMaterial);
        orbitSphere.userData = {
          angle: (i * Math.PI * 2) / orbitCount,
          radius: 10 + Math.random() * 5,
          speed: 0.01 + Math.random() * 0.015,
          verticalOffset: Math.random() * Math.PI * 2,
          verticalAmplitude: 2 + Math.random() * 3,
        };
        sphereGroup.add(orbitSphere);
        spheres.push({ mesh: orbitSphere, baseScale: 0.8, type: 'orbit' });
      }
      
      scene.add(sphereGroup);

      // Particle system
      const particleCount = 1500;
      const particleGeometry = new THREE.BufferGeometry();
      const particlePositions = new Float32Array(particleCount * 3);
      const particleVelocities = new Float32Array(particleCount);
      const particleColors = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = 20 + Math.random() * 40;
        
        particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        particlePositions[i3 + 2] = radius * Math.cos(phi);
        particleVelocities[i] = 0.02 + Math.random() * 0.05;
        
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 0.9, 0.7);
        particleColors[i3] = color.r;
        particleColors[i3 + 1] = color.g;
        particleColors[i3 + 2] = color.b;
      }
      
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
      
      const particleMaterial = new THREE.PointsMaterial({
        size: 0.15,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.8,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      
      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      // Ring geometry
      const ringGroup = new THREE.Group();
      for (let i = 0; i < 5; i++) {
        const ringGeometry = new THREE.TorusGeometry(8 + i * 4, 0.1 + i * 0.05, 16, 100);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(i * 0.15 + 0.8, 0.9, 0.6),
          transparent: true,
          opacity: 0.4 - i * 0.05,
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = Math.PI / 2 + Math.random() * 0.3;
        ring.rotation.y = Math.random() * Math.PI;
        ringGroup.add(ring);
      }
      scene.add(ringGroup);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const pointLight1 = new THREE.PointLight(0xff66aa, 2.5, 100);
      pointLight1.position.set(15, 15, 15);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0x00ffcc, 2, 100);
      pointLight2.position.set(-15, -10, 15);
      scene.add(pointLight2);

      const pointLight3 = new THREE.PointLight(0x6644ff, 1.5, 100);
      pointLight3.position.set(0, 20, -15);
      scene.add(pointLight3);

      camera.position.z = 35;

      // SVG Elements
      const turbulence = document.getElementById('turbulence');
      const displacementMap = document.getElementById('displacementMap');
      const mainOrb = document.getElementById('mainOrb');
      const innerRing = document.getElementById('innerRing');
      const outerRings = document.getElementById('outerRings');
      const glowStop1 = document.getElementById('glowStop1');
      const glowStop2 = document.getElementById('glowStop2');
      const ringStops = [
        document.getElementById('ringStop1'),
        document.getElementById('ringStop2'),
        document.getElementById('ringStop3'),
      ];
      const waveforms = [
        document.getElementById('waveform1'),
        document.getElementById('waveform2'),
        document.getElementById('waveform3'),
      ];
      const freqBarsGroup = document.getElementById('freqBars');
      const sparksGroup = document.getElementById('sparks');
      const hexGrid = document.getElementById('hexGrid');
      const triangles = document.getElementById('triangles');

      // Create frequency bars (radial)
      const barCount = 64;
      for (let i = 0; i < barCount; i++) {
        const angle = (i / barCount) * Math.PI * 2 - Math.PI / 2;
        const bar = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        bar.setAttribute('data-bar-index', i);
        bar.setAttribute('x1', Math.cos(angle) * 150);
        bar.setAttribute('y1', Math.sin(angle) * 150);
        bar.setAttribute('x2', Math.cos(angle) * 180);
        bar.setAttribute('y2', Math.sin(angle) * 180);
        bar.setAttribute('stroke', `hsl(${(i / barCount) * 360}, 80%, 60%)`);
        bar.setAttribute('stroke-width', '3');
        bar.setAttribute('stroke-linecap', 'round');
        freqBarsGroup.appendChild(bar);
      }

      // Create hexagonal grid background
      function createHexGrid() {
        hexGrid.innerHTML = '';
        const hexSize = 40;
        const cols = Math.ceil(window.innerWidth / (hexSize * 1.5)) + 2;
        const rows = Math.ceil(window.innerHeight / (hexSize * Math.sqrt(3))) + 2;
        
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const x = col * hexSize * 1.5;
            const y = row * hexSize * Math.sqrt(3) + (col % 2) * hexSize * Math.sqrt(3) / 2;
            
            const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            const points = [];
            for (let i = 0; i < 6; i++) {
              const angle = (i * 60 - 30) * Math.PI / 180;
              points.push(`${x + hexSize/2 * Math.cos(angle)},${y + hexSize/2 * Math.sin(angle)}`);
            }
            hex.setAttribute('points', points.join(' '));
            hex.setAttribute('fill', 'none');
            hex.setAttribute('stroke', 'rgba(100, 68, 255, 0.1)');
            hex.setAttribute('stroke-width', '1');
            hex.setAttribute('data-hex-index', row * cols + col);
            hexGrid.appendChild(hex);
          }
        }
      }
      createHexGrid();

      // Create triangle patterns
      function createTriangles() {
        triangles.innerHTML = '';
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;
        
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const radius = 300 + Math.random() * 100;
          const size = 30 + Math.random() * 20;
          
          const x = cx + Math.cos(angle) * radius;
          const y = cy + Math.sin(angle) * radius;
          
          const tri = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          const points = [];
          for (let j = 0; j < 3; j++) {
            const triAngle = (j * 120 - 90) * Math.PI / 180 + angle;
            points.push(`${x + size * Math.cos(triAngle)},${y + size * Math.sin(triAngle)}`);
          }
          tri.setAttribute('points', points.join(' '));
          tri.setAttribute('fill', 'none');
          tri.setAttribute('stroke', `hsla(${i * 30}, 80%, 60%, 0.3)`);
          tri.setAttribute('stroke-width', '2');
          tri.setAttribute('data-tri-index', i);
          triangles.appendChild(tri);
        }
      }
      createTriangles();

      const toy = {
        camera,
        renderer,
        analyser: null,
        audioCleanup: null,
        async initAudio(options = {}) {
          const audio = await initAudio({ ...options, camera });
          this.analyser = audio.analyser;
          this.audioCleanup = audio.cleanup;
          return audio;
        },
        dispose() {
          if (this.renderer?.setAnimationLoop) {
            this.renderer.setAnimationLoop(null);
          }
          this.audioCleanup?.();
        },
      };

      // Handle resize
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        createHexGrid();
        createTriangles();
      });

      // Mode buttons
      document.querySelectorAll('.control-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.control-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentMode = btn.dataset.mode;
          document.getElementById('currentMode').textContent = 
            currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
        });
      });

      let audioDataArray = new Uint8Array(256);
      let time = 0;
      let smoothedBass = 0;
      let smoothedMids = 0;
      let smoothedHighs = 0;
      let beatIntensity = 0;
      let lastBeatTime = 0;

      function detectBeat(bass, currentTime) {
        const threshold = 0.6;
        const minInterval = 150;
        if (bass > threshold && currentTime - lastBeatTime > minInterval) {
          lastBeatTime = currentTime;
          return true;
        }
        return false;
      }

      function generateWaveformPath(data, yOffset, amplitude, phase) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const centerY = height / 2 + yOffset;
        let path = `M 0 ${centerY}`;
        
        for (let i = 0; i < data.length; i++) {
          const x = (i / data.length) * width;
          const value = data[i] / 255;
          const y = centerY + Math.sin(i * 0.1 + phase) * value * amplitude;
          path += ` L ${x} ${y}`;
        }
        
        return path;
      }

      function animate(ctxAudio) {
        time += 16;
        const now = performance.now();
        
        // FPS calculation
        frameCount++;
        if (now - lastFrameTime >= 1000) {
          document.getElementById('fpsCounter').textContent = frameCount;
          frameCount = 0;
          lastFrameTime = now;
        }

        let avgFrequency = 0;
        let bassFrequency = 0;
        let midsFrequency = 0;
        let highFrequency = 0;

        if (ctxAudio.analyser) {
          audioDataArray = getFrequencyData(ctxAudio.analyser);
          const len = audioDataArray.length;
          
          avgFrequency = audioDataArray.reduce((sum, val) => sum + val, 0) / len;
          bassFrequency = audioDataArray.slice(0, Math.floor(len * 0.15)).reduce((sum, val) => sum + val, 0) / Math.floor(len * 0.15);
          midsFrequency = audioDataArray.slice(Math.floor(len * 0.15), Math.floor(len * 0.6)).reduce((sum, val) => sum + val, 0) / Math.floor(len * 0.45);
          highFrequency = audioDataArray.slice(Math.floor(len * 0.6)).reduce((sum, val) => sum + val, 0) / Math.floor(len * 0.4);
        }

        const normalizedAvg = avgFrequency / 255;
        const bass = bassFrequency / 255;
        const mids = midsFrequency / 255;
        const highs = highFrequency / 255;
        
        smoothedBass = smoothedBass * 0.85 + bass * 0.15;
        smoothedMids = smoothedMids * 0.9 + mids * 0.1;
        smoothedHighs = smoothedHighs * 0.92 + highs * 0.08;
        
        const isBeat = detectBeat(smoothedBass, time);
        if (isBeat) beatIntensity = 1;
        beatIntensity *= 0.9;
        
        document.getElementById('bassLevel').textContent = Math.round(smoothedBass * 100);

        // === THREE.JS ANIMATION ===
        
        // Main sphere
        const mainScale = 1 + smoothedBass * 0.6 + beatIntensity * 0.4;
        mainSphere.scale.set(mainScale, mainScale, mainScale);
        mainSphere.rotation.x += 0.008 + smoothedMids * 0.02;
        mainSphere.rotation.y += 0.012 + smoothedHighs * 0.015;
        mainMaterial.emissiveIntensity = 0.3 + smoothedBass * 0.7;
        mainMaterial.emissive.setHSL((time * 0.0001) % 1, 0.8, 0.4);

        // Orbiting spheres
        spheres.forEach((item, index) => {
          if (item.type === 'orbit') {
            const mesh = item.mesh;
            const ud = mesh.userData;
            
            ud.angle += ud.speed * (1 + smoothedBass * 1.5);
            mesh.position.x = Math.cos(ud.angle) * ud.radius;
            mesh.position.z = Math.sin(ud.angle) * ud.radius;
            mesh.position.y = Math.sin(ud.angle * 2 + ud.verticalOffset) * ud.verticalAmplitude;
            
            const orbScale = item.baseScale * (1 + smoothedHighs * 0.4 + beatIntensity * 0.3);
            mesh.scale.set(orbScale, orbScale, orbScale);
            
            mesh.material.emissiveIntensity = 0.2 + smoothedMids * 0.5;
          }
        });

        // Particles
        const positions = particles.geometry.attributes.position.array;
        const colors = particles.geometry.attributes.color.array;
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const x = positions[i3];
          const y = positions[i3 + 1];
          const z = positions[i3 + 2];
          
          // Orbital motion with audio influence
          const angle = Math.atan2(y, x);
          const radius = Math.sqrt(x * x + y * y);
          const newAngle = angle + particleVelocities[i] * (1 + smoothedMids * 2);
          
          positions[i3] = Math.cos(newAngle) * radius;
          positions[i3 + 1] = Math.sin(newAngle) * radius;
          positions[i3 + 2] += (smoothedBass * 4 - 1) * 0.3;
          
          // Wrap around
          if (positions[i3 + 2] > 30) positions[i3 + 2] = -30;
          if (positions[i3 + 2] < -30) positions[i3 + 2] = 30;
          
          // Color animation
          const hue = (i / particleCount + time * 0.00003 + smoothedHighs * 0.2) % 1;
          const color = new THREE.Color().setHSL(hue, 0.9, 0.5 + smoothedHighs * 0.3);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        particleMaterial.size = 0.15 + smoothedBass * 0.3;
        particleMaterial.opacity = 0.6 + smoothedHighs * 0.4;

        // Rings
        ringGroup.children.forEach((ring, i) => {
          ring.rotation.z += 0.003 * (i % 2 === 0 ? 1 : -1) * (1 + smoothedMids);
          ring.rotation.x += 0.002 * (1 + smoothedBass * 0.5);
          const ringScale = 1 + smoothedBass * 0.2 * (i + 1) / 5;
          ring.scale.set(ringScale, ringScale, 1);
        });

        // Lights
        pointLight1.intensity = 2 + smoothedBass * 3;
        pointLight2.intensity = 1.5 + smoothedHighs * 2.5;
        pointLight3.intensity = 1 + smoothedMids * 2;
        
        pointLight1.position.x = Math.sin(time * 0.001) * 20;
        pointLight1.position.y = Math.cos(time * 0.0008) * 15;

        // Camera
        camera.position.x = Math.sin(time * 0.0003) * 10;
        camera.position.y = Math.cos(time * 0.0004) * 8;
        camera.lookAt(0, 0, 0);

        // Visibility based on mode
        sphereGroup.visible = currentMode === 'hybrid' || currentMode === 'spheres';
        particles.visible = currentMode === 'hybrid' || currentMode === 'spheres';
        ringGroup.visible = currentMode === 'hybrid' || currentMode === 'spheres';

        renderer.render(scene, camera);

        // === SVG ANIMATION ===
        
        // Displacement filter
        if (turbulence) {
          const baseFreq = 0.015 + smoothedBass * 0.015;
          turbulence.setAttribute('baseFrequency', baseFreq.toString());
        }
        if (displacementMap) {
          const scale = 50 + smoothedBass * 80 + beatIntensity * 40;
          displacementMap.setAttribute('scale', scale.toString());
        }

        // Main orb
        if (mainOrb) {
          const radius = 100 + smoothedBass * 80 + beatIntensity * 40;
          mainOrb.setAttribute('r', radius.toString());
        }

        // Inner ring
        if (innerRing) {
          const radius = 60 + smoothedMids * 40;
          innerRing.setAttribute('r', radius.toString());
          innerRing.setAttribute('stroke-width', (2 + smoothedHighs * 3).toString());
        }

        // Gradient colors
        if (glowStop1) {
          const hue = (time * 0.02) % 360;
          glowStop1.style.stopColor = `hsl(${hue}, 100%, ${70 + smoothedBass * 30}%)`;
        }
        if (glowStop2) {
          const hue = (time * 0.02 + 120) % 360;
          glowStop2.style.stopColor = `hsl(${hue}, 90%, ${50 + smoothedMids * 30}%)`;
        }
        
        ringStops.forEach((stop, i) => {
          if (stop) {
            const hue = (time * 0.015 + i * 120) % 360;
            stop.style.stopColor = `hsl(${hue}, 85%, 60%)`;
          }
        });

        // Frequency bars
        const bars = freqBarsGroup.querySelectorAll('line');
        bars.forEach((bar, i) => {
          const freqIndex = Math.floor((i / barCount) * audioDataArray.length);
          const value = audioDataArray[freqIndex] / 255;
          const angle = (i / barCount) * Math.PI * 2 - Math.PI / 2;
          const innerRadius = 140;
          const outerRadius = 160 + value * 100;
          
          bar.setAttribute('x1', (Math.cos(angle) * innerRadius).toString());
          bar.setAttribute('y1', (Math.sin(angle) * innerRadius).toString());
          bar.setAttribute('x2', (Math.cos(angle) * outerRadius).toString());
          bar.setAttribute('y2', (Math.sin(angle) * outerRadius).toString());
          bar.setAttribute('stroke-width', (2 + value * 4).toString());
          bar.setAttribute('opacity', (0.4 + value * 0.6).toString());
        });

        // Waveforms
        if (currentMode === 'waveform' || currentMode === 'hybrid') {
          waveforms.forEach((wf, i) => {
            if (wf) {
              const path = generateWaveformPath(audioDataArray, (i - 1) * 60, 80 - i * 15, time * 0.003 + i);
              wf.setAttribute('d', path);
              wf.setAttribute('opacity', (0.6 - i * 0.1 + smoothedHighs * 0.3).toString());
            }
          });
        }

        // Hexagonal grid pulse
        if (currentMode === 'geometric' || currentMode === 'hybrid') {
          const hexes = hexGrid.querySelectorAll('polygon');
          hexes.forEach((hex, i) => {
            const freqIndex = i % audioDataArray.length;
            const value = audioDataArray[freqIndex] / 255;
            hex.setAttribute('stroke', `rgba(100, 68, 255, ${0.05 + value * 0.4})`);
            hex.setAttribute('stroke-width', (0.5 + value * 2).toString());
          });
          
          const tris = triangles.querySelectorAll('polygon');
          tris.forEach((tri, i) => {
            const value = audioDataArray[i * 8 % audioDataArray.length] / 255;
            tri.setAttribute('stroke', `hsla(${(i * 30 + time * 0.05) % 360}, 80%, ${50 + value * 30}%, ${0.2 + value * 0.5})`);
            const scale = 1 + value * 0.3;
            tri.style.transform = `scale(${scale})`;
            tri.style.transformOrigin = 'center';
          });
        }
      }

      startToyAudio(toy, animate, { fftSize: 512, fallbackToSynthetic: true })
        .then(() => hideError())
        .catch((err) => {
          console.error('Error capturing audio: ', err);
          displayError(
            'Microphone access is required for the visualization to work. Please allow microphone access.'
          );
          toy.renderer.setAnimationLoop(() => animate({ toy, analyser: null }));
        });

      window.addEventListener('pagehide', () => toy.dispose());
    </script>
  </body>
</html>
